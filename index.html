<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta
      http-equiv="Content-Security-Policy"
      content="script-src 'self' 'unsafe-inline';"
    />
    <title>GAD QR-Scanning System</title>
    <style>
      *,
      *::before,
      *::after {
        box-sizing: border-box;
      }

      html,
      body {
        height: 100vh;
        margin: 0;
        padding: 0;
        overflow: hidden;
      }

      :root {
        /* Theme variables (added for accessible contrasts) */
        --bg: #001d4a;
        --panel: #003366;
        --primary: #3399ff;
        --primary-dark: #1f4e79;
        --primary-contrast: #ffffff;
        --accent-yellow: #ffd54f; /* modern warm yellow */
        --accent-yellow-text: #21210a;
        --accent-yellow-green: #c7ea46; /* yellow-green accent */
        --accent-third: #00bfa5; /* teal/emerald third accent */
        --accent-orange: #ff8a00;
        --accent-orange-text: #000000;
        --accent-green: #00c853; /* darker green for contrast */
        --accent-green-text: #000000;
        --danger: #ff4d4f; /* accessible red */
        --muted: #cbd7e6;
        --text-on-dark: #ffffff;
        --text-on-light: #000000;
      }

      body {
        font-family:
          "Montserrat",
          system-ui,
          -apple-system,
          "Segoe UI",
          Roboto,
          "Helvetica Neue",
          Arial,
          sans-serif;
        background-color: var(--bg);
        color: var(--text-on-dark);
        display: flex;
        min-height: 100vh;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }

      .container {
        flex: 1;
        margin: 0;
        padding: 20px;
        background-color: #003366;
        display: flex;
        flex-direction: column;
        overflow-y: auto;
        height: 100vh;
      }

      .header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 16px;
        flex-wrap: wrap;
        padding: 8px 0 12px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.12);
      }

      .header h1 {
        font-size: 28px;
        color: var(--text-on-dark);
        margin: 0;
        line-height: 1.1;
        flex: 1;
        min-width: 220px;
      }

      .logo {
        font-weight: bold;
        color: var(--text-on-dark);
        background: radial-gradient(circle, red 10%, black 50%);
        padding: 10px;
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
        min-width: 86px;
        height: 56px;
        flex: 0 0 auto;
      }

      .logo img {
        max-height: 48px;
        max-width: 76px;
        width: auto;
        height: auto;
        object-fit: contain;
        display: none; /* Hidden by default until loaded */
      }

      .logo-text {
        display: block; /* Shown by default */
      }

      .buttons {
        display: flex;
        gap: 10px;
        flex: 0 0 auto;
        flex-wrap: wrap;
        justify-content: flex-end;
      }

      .buttons button {
        background-color: #3399ff;
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 6px;
        cursor: pointer;
        font-weight: bold;
        font-size: 16px;
        min-width: 100px;
        min-height: 44px;
        line-height: 1;
      }

      .buttons button:active {
        transform: translateY(1px);
      }

      .buttons button:focus-visible {
        outline: 2px solid rgba(255, 255, 255, 0.5);
        outline-offset: 2px;
      }

      .main {
        display: flex;
        margin-top: 20px;
        flex: 1;
        gap: 20px;
        flex-wrap: wrap;
      }

      .input-section {
        background-color: #0070c0;
        border-radius: 15px;
        padding: 20px;
        flex: 2;
        min-width: 300px;
        display: flex;
        flex-direction: column;
      }

      .input-section h2 {
        color: #fff;
        font-size: 24px;
        margin-bottom: 10px;
      }

      .row {
        display: flex;
        margin-bottom: 10px;
        align-items: center;
      }

      .row label {
        width: 120px;
        font-weight: bold;
        font-size: 18px;
      }

      .row input {
        flex: 1;
        padding: 12px 15px;
        background-color: #003366;
        border: 1px solid #3399ff;
        color: white;
        font-weight: bold;
        font-size: 20px;
        border-radius: 4px;
        margin: 5px 0;
      }

      .row input.required {
        border-color: red;
      }

      .verification {
        margin-top: 20px;
        display: flex;
        flex-direction: column;
        height: calc(100% - 40px); /* Adjust based on your layout */
      }

      .verification h3 {
        color: #fff;
        margin-bottom: 10px;
        font-size: 18px;
      }

      .verify-row {
        display: flex;
        margin-bottom: 10px;
        align-items: stretch;
        flex: 1;
      }

      .verify-row button {
        background-color: #1f4e79;
        color: white;
        border: none;
        padding: 20px 30px;
        font-weight: bold;
        margin-right: 15px;
        font-size: 26px;
        border-radius: 8px;
        cursor: pointer;
        min-width: 200px;
        transition: all 0.2s;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        flex: 1;
        white-space: normal;
        text-align: center;
      }

      .verify-row button.failed {
        background-color: #ff3b30;
      }

      .verify-row button:hover {
        transform: scale(1.05);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
      }

      .verify-row .value {
        background-color: #003366;
        padding: 20px;
        color: white;
        font-weight: bold;
        font-size: 24px;
        border: 1px solid #3399ff;
        border-radius: 6px;
        min-width: 200px;
        text-align: center;
        display: flex;
        align-items: center;
        justify-content: center;
        flex: 2;
      }

      .ok {
        background-color: #00ff99;
        color: black;
        font-weight: bold;
      }

      .scanned-success {
        color: #00ff00 !important;
      }

      .right-section {
        background-color: #001d4a;
        flex: 1;
        padding: 10px;
        text-align: center;
        display: flex;
        flex-direction: column;
        height: 100%;
      }

      .right-section .info-box {
        background-color: #0070c0;
        margin-bottom: 10px;
        padding: 10px;
        border-radius: 5px;
      }

      .info-box label {
        display: block;
        font-size: 18px;
      }

      .info-box input {
        width: 120px;
        padding: 10px 12px;
        font-weight: bold;
        background-color: #003366;
        color: white;
        border: 1px solid #3399ff;
        border-radius: 4px;
        font-size: 20px;
        margin: 5px 0;
      }

      #date {
        width: 140px;
      }

      .status {
        margin-top: 20px;
        color: #fff;
      }

      .pass-box {
        background-color: limegreen;
        color: black;
        font-size: 42px;
        font-weight: bold;
        padding: 30px 0;
        margin-top: 10px;
        border-radius: 8px;
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        min-height: 150px; /* Ensure minimum height */
      }

      /* Intermediate sequential pass (yellow) */
      .interim-pass {
        background: linear-gradient(90deg, #ffd54f, #ffb300);
        color: #000;
        font-size: 42px;
        font-weight: bold;
        padding: 30px 0;
        margin-top: 10px;
        border-radius: 8px;
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        min-height: 150px;
      }

      .failed {
        background-color: red;
        color: white;
        font-size: 42px;
        font-weight: bold;
        padding: 30px 0;
        margin-top: 10px;
        border-radius: 8px;
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        min-height: 150px; /* Ensure minimum height */
      }

      #pass-status:not(.pass-box):not(.failed) {
        background-color: #1f4e79;
        color: white;
        font-size: 36px;
        font-weight: bold;
        padding: 30px 0;
        margin-top: 10px;
        border-radius: 8px;
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        min-height: 150px; /* Ensure minimum height */
      }

      @media (max-width: 768px) {
        .header {
          flex-direction: column;
          text-align: center;
          gap: 15px;
        }

        .main {
          flex-direction: column;
        }

        .input-section,
        .right-section {
          width: 100%;
        }

        .row {
          flex-direction: column;
          align-items: flex-start;
          gap: 5px;
        }

        .row label {
          width: 100%;
        }

        .row input {
          width: 100%;
        }

        .verify-row {
          flex-direction: column;
          gap: 5px;
        }

        .verify-row button {
          width: 100%;
          margin-right: 0;
        }

        .verify-row .value {
          width: 100%;
        }

        .info-box input {
          width: 100%;
        }
      }

      /* Modal Styles */
      .modal {
        /* Hidden by default; shown by setting display:flex on demand */
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        color: var(--text-on-dark);
        width: 100%;
        height: 100%;
        /* subtle, light black overlay with soft blur */
        background-color: rgba(0, 0, 0, 0.28);
        -webkit-backdrop-filter: blur(6px);
        backdrop-filter: blur(6px);
        align-items: center;
        justify-content: center;
        padding: 20px;
        transition:
          background-color 200ms ease,
          opacity 160ms ease;
      }

      .modal-content {
        position: relative;
        background-color: var(--panel);
        margin: 0 auto;
        padding: 28px;
        width: 100%;
        max-width: 1100px;
        border-radius: 12px;
        /* Ensure modal content is scrollable when content is large, keep visual height */
        max-height: 80vh;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
        border: 1px solid rgba(255, 255, 255, 0.04);
      }

      .modal-header {
        position: relative;
        display: flex;
        align-items: center;
        margin-bottom: 20px;
        padding-right: 40px;
      }

      .modal-title {
        color: var(--text-on-dark);
        font-size: 26px;
        margin: 0;
        flex: 1;
        font-weight: 800;
      }

      .close-modal {
        position: absolute;
        top: 10px;
        right: 10px;
        color: white;
        font-size: 24px;
        font-weight: bold;
        cursor: pointer;
        background-color: #ff3b30;
        border: 2px solid white;
        padding: 0;
        width: 32px;
        height: 32px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 50%;
        transition: all 0.2s;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        margin-left: 0;
      }

      .close-modal:hover {
        background-color: #ff1a1a;
        transform: scale(1.1);
        box-shadow: 0 3px 6px rgba(0, 0, 0, 0.3);
      }

      .search-box {
        width: 100%;
        padding: 15px 20px;
        margin-bottom: 25px;
        background-color: #001d4a;
        border: 2px solid #3399ff;
        color: white;
        font-size: 18px;
        border-radius: 8px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      }

      .parts-list {
        list-style: none;
        margin: 0;
        padding: 0;
        max-height: 70vh;
        overflow-y: auto;
      }

      .part-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 10px;
        background-color: #0070c0;
        margin-bottom: 10px;
        border-radius: 5px;
        cursor: pointer;
        transition: background-color 0.2s;
        border-left: 6px solid var(--accent-yellow-green);
        padding-left: 14px;
      }

      .part-item:hover {
        background-color: #1f4e79;
        transform: translateY(-2px);
        box-shadow: 0 6px 18px rgba(0, 0, 0, 0.26);
        border-left-color: var(--primary);
      }

      /* Grouping cards (Master modal drill-down) */
      .group-value-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 20px 20px;
        background: linear-gradient(
          180deg,
          rgba(0, 122, 204, 0.03),
          rgba(0, 112, 192, 0.02)
        );
        color: var(--text-on-dark);
        margin-bottom: 16px;
        border-radius: 14px;
        cursor: pointer;
        transition:
          transform 0.18s ease,
          box-shadow 0.18s ease,
          background-color 0.12s ease;
        border: 1px solid rgba(255, 255, 255, 0.04);
        box-shadow: 0 8px 22px rgba(3, 10, 24, 0.14);
      }

      .group-value-item:hover {
        background-color: rgba(31, 78, 121, 0.1);
        transform: translateY(-6px);
        box-shadow:
          0 18px 48px rgba(3, 10, 24, 0.32),
          0 0 18px rgba(0, 191, 165, 0.06);
      }

      .group-card-title {
        font-weight: 700;
        color: var(--accent-yellow);
        font-size: 24px;
        line-height: 1.12;
        letter-spacing: -0.3px;
        margin-bottom: 6px;
      }

      .group-card-subtitle {
        color: var(--muted);
        opacity: 0.98;
        font-size: 16px;
        margin-top: 2px;
      }

      .group-card-meta {
        color: var(--muted);
        opacity: 0.98;
        font-size: 15px;
        text-align: right;
        min-width: 140px;
        font-weight: 700;
        display: flex;
        flex-direction: column;
        align-items: flex-end;
        gap: 6px;
      }

      .group-meta-badge {
        background: var(--accent-yellow-green);
        color: var(--accent-yellow-text);
        padding: 6px 10px;
        border-radius: 999px;
        font-weight: 800;
        font-size: 0.95em;
      }

      .part-info {
        flex-grow: 1;
      }

      .part-code {
        font-weight: bold;
        color: var(--accent-yellow);
        font-size: 1.2em;
      }

      .part-badge {
        display: inline-block;
        background: var(--accent-yellow);
        color: var(--accent-yellow-text);
        padding: 2px 8px;
        border-radius: 12px;
        font-size: 0.95em;
        font-weight: 700;
        margin-left: 8px;
      }

      .index-badge {
        display: inline-block;
        background: rgba(255, 255, 255, 0.06);
        color: var(--accent-yellow-green);
        padding: 2px 6px;
        border-radius: 8px;
        font-weight: 700;
        margin-right: 8px;
        font-size: 0.95em;
      }

      .highlight-third {
        color: var(--accent-third);
      }

      /* Group summary styling */
      .group-summary .summary-title {
        color: var(--text-on-dark);
        font-weight: 800;
        font-size: 15px;
        margin-bottom: 6px;
      }
      .group-summary .summary-note {
        color: var(--muted);
        margin-top: 6px;
      }

      .part-name {
        color: var(--muted);
        margin-left: 20px;
        font-size: 16px;
      }

      .part-customer {
        color: var(--muted);
        font-size: 0.95em;
      }

      .no-results {
        text-align: center;
        color: #fff;
        padding: 20px;
      }

      /* Scan Logs Styles */
      .scan-logs {
        margin-top: 20px;
        max-height: 70vh;
        overflow-y: auto;
      }

      .logs-table {
        width: 100%;
        border-collapse: collapse;
        color: white;
      }

      .logs-table th,
      .logs-table td {
        padding: 10px;
        text-align: left;
        border-bottom: 1px solid #1f4e79;
      }

      .logs-table th {
        background-color: #1f4e79;
        color: #fff;
        position: sticky;
        top: 0;
      }

      .logs-table tr.match td {
        background-color: rgba(0, 255, 0, 0.1);
      }

      .logs-table tr.no-match td {
        background-color: rgba(255, 0, 0, 0.1);
      }

      .logs-table tr:hover td {
        background-color: #1f4e79;
      }

      .shake {
        animation: shake 0.5s;
      }

      @keyframes shake {
        0%,
        100% {
          transform: translateX(0);
        }
        10%,
        30%,
        50%,
        70%,
        90% {
          transform: translateX(-10px);
        }
        20%,
        40%,
        60%,
        80% {
          transform: translateX(10px);
        }
      }

      .blink-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(255, 0, 0, 0.5);
        display: none;
        animation: blink 2s 3;
        pointer-events: none;
        z-index: 10;
      }

      @keyframes blink {
        0% {
          opacity: 1;
        }
        50% {
          opacity: 0;
        }
        100% {
          opacity: 0;
        }
      }

      /* Multi-field scan highlight states */
      .scan-pending {
        background-color: var(--accent-yellow); /* yellow */
        color: var(--accent-yellow-text);
      }

      .scan-active {
        background-color: var(--accent-orange); /* orange */
        color: var(--accent-orange-text);
      }

      .scan-passed {
        background-color: var(--accent-green); /* green */
        color: var(--accent-green-text);
      }

      .scan-failed {
        background-color: #ff3b30; /* red */
        color: white;
      }
      /* When performing master-item selection (PIN flow), suppress scan-failed visuals
         so fields populated from master do not appear as scan failures. */
      .suppress-scan-fail .scan-failed,
      .suppress-scan-fail .failed {
        background: transparent !important;
        color: inherit !important;
        border: none !important;
        box-shadow: none !important;
        outline: none !important;
      }
    </style>

    <!-- Local Server Modal -->

    <div
      id="web-server-modal"
      class="modal"
      style="display: none; z-index: 10020"
    >
      <div class="modal-content" style="max-width: 480px">
        <div class="modal-header">
          <h2 class="modal-title">Local LAN Server</h2>
        </div>
        <div style="padding: 16px">
          <div
            id="server-status-text"
            style="margin-bottom: 8px; font-size: 14px"
          >
            Server status: unknown
          </div>
          <div
            style="
              display: flex;
              gap: 8px;
              margin-bottom: 8px;
              align-items: center;
            "
          >
            <select
              id="server-display-ip"
              style="flex: 1; padding: 6px"
            ></select>
            <button id="btn-refresh-ips" style="padding: 6px 8px">
              Refresh
            </button>
          </div>
          <div style="display: flex; gap: 8px; margin-bottom: 8px">
            <button id="btn-generate-tls" style="flex: 1; padding: 8px">
              Generate TLS
            </button>
            <button id="btn-start-stop" style="flex: 1; padding: 8px">
              Start
            </button>
          </div>
          <div
            id="server-url"
            style="word-break: break-all; margin-bottom: 8px; font-weight: 700"
          ></div>
          <div id="server-qr" style="margin-bottom: 8px"></div>
          <div
            style="
              display: flex;
              align-items: center;
              gap: 8px;
              margin-bottom: 8px;
            "
          >
            <input type="checkbox" id="server-autostart" />
            <label for="server-autostart" style="font-size: 13px"
              >Auto-start server on app launch</label
            >
          </div>
          <div style="display: flex; gap: 8px">
            <button id="btn-download-ca" style="padding: 8px">
              Download CA
            </button>
            <button id="btn-close-server-modal" style="padding: 8px">
              Close
            </button>
          </div>
        </div>
      </div>
    </div>

    <script>
      (function () {
        try {
          const init = async function () {
            try {
              const { ipcRenderer } = require("electron");

              const btn = document.getElementById("btn-start-server");
              const modal = document.getElementById("web-server-modal");
              const closeBtn = document.getElementById(
                "btn-close-server-modal",
              );
              const startStop = document.getElementById("btn-start-stop");
              const genTls = document.getElementById("btn-generate-tls");
              const refreshIps = document.getElementById("btn-refresh-ips");
              const selectIp = document.getElementById("server-display-ip");
              const statusText = document.getElementById("server-status-text");
              const urlEl = document.getElementById("server-url");
              const qrEl = document.getElementById("server-qr");
              const downloadCa = document.getElementById("btn-download-ca");
              const updateMasterBtn =
                document.getElementById("btn-update-master");
              const masterModalId = "master-link-modal";

              // Create master link modal container (lazy)
              function ensureMasterModal() {
                let m = document.getElementById(masterModalId);
                if (m) return m;
                m = document.createElement("div");
                m.id = masterModalId;
                m.className = "modal";
                m.style.display = "none";
                m.style.zIndex = 10030;
                m.innerHTML = `<div class="modal-content" style="max-width:480px"><div class="modal-header"><h2 class="modal-title">Update Master</h2></div><div style="padding:16px"><div id="master-link-status">Loading...</div><div id="master-link-qr" style="margin-top:8px"></div><div style="margin-top:12px"><button id="master-open-link">Open Link</button><button id="master-close" style="margin-left:8px">Close</button></div></div></div>`;
                document.body.appendChild(m);
                return m;
              }

              if (updateMasterBtn) {
                updateMasterBtn.addEventListener("click", async () => {
                  try {
                    // Ensure server is running before opening the Update Master modal
                    const stCheck =
                      await ipcRenderer.invoke("get-server-status");
                    if (!stCheck || !stCheck.success || !stCheck.isRunning) {
                      window.alert(
                        "Web server is not running. Start the web server before using Update Master.",
                      );
                      return;
                    }

                    const modal = ensureMasterModal();
                    const status = modal.querySelector("#master-link-status");
                    const qrEl = modal.querySelector("#master-link-qr");
                    const openBtn = modal.querySelector("#master-open-link");
                    const closeBtn = modal.querySelector("#master-close");
                    modal.style.display = "block";
                    status.textContent = "Fetching server status...";
                    const st = stCheck;
                    const base =
                      st.url ||
                      (st.isRunning
                        ? `${st.ipAddress ? st.ipAddress : "localhost"}:${
                            st.port
                          }`
                        : "");
                    const masterUrl =
                      (base || "").replace(/\/$/, "") + "/master";
                    status.innerHTML = `<div style="word-break:break-all">${masterUrl}</div>`;
                    // request QR from server API
                    try {
                      const qResp = await fetch(
                        (st.url || (st.isRunning ? st.url : "")) +
                          "/api/qrcode?url=" +
                          encodeURIComponent(masterUrl),
                      );
                      const qj = await qResp.json();
                      if (qj && qj.success && qj.qr)
                        qrEl.innerHTML = `<img src="${qj.qr}" alt="qr"/>`;
                      else qrEl.innerHTML = "";
                    } catch (e) {
                      qrEl.innerHTML = "";
                    }
                    openBtn.onclick = () => {
                      try {
                        window.open(masterUrl, "_blank");
                      } catch (e) {}
                    };
                    closeBtn.onclick = () => {
                      modal.style.display = "none";
                    };
                  } catch (e) {
                    console.error("open master modal failed", e);
                  }
                });
              }
              const autostartCheckbox =
                document.getElementById("server-autostart");

              if (!btn) return;

              async function refreshStatus() {
                try {
                  const st = await ipcRenderer.invoke("get-server-status");
                  // also refresh auto-start setting
                  try {
                    const cfg = await ipcRenderer.invoke(
                      "get-web-server-config",
                    );
                    if (cfg && cfg.success && cfg.config && autostartCheckbox) {
                      autostartCheckbox.checked = !!cfg.config.autoStart;
                    }
                  } catch (e) {}
                  if (st && st.isRunning) {
                    if (statusText) statusText.textContent = "Server running";
                    if (startStop) startStop.textContent = "Stop";
                    // Prefer showing mobileUrl (if present) so QR opens mobile UI directly
                    const displayUrl = st.mobileUrl || st.url || "";
                    if (urlEl)
                      urlEl.innerHTML = `<a href="${displayUrl}" target="_blank" rel="noreferrer noopener">${displayUrl}</a>`;
                    if (qrEl && st.qrCode)
                      qrEl.innerHTML = `<a href="${displayUrl}" target="_blank" rel="noreferrer noopener"><img src="${st.qrCode}" alt="qr"/></a>`;
                  } else {
                    if (statusText) statusText.textContent = "Server stopped";
                    if (startStop) startStop.textContent = "Start";
                    if (urlEl) urlEl.textContent = "";
                    if (qrEl) qrEl.innerHTML = "";
                  }
                } catch (e) {
                  console.error(e);
                }
              }

              async function refreshIpsList() {
                try {
                  const res = await ipcRenderer.invoke("get-local-ips");
                  if (!selectIp) return;
                  selectIp.innerHTML = "";
                  if (res && res.success && Array.isArray(res.ips)) {
                    // Prefer wifi interfaces first, then lan, then others
                    const order = { wifi: 0, lan: 1, other: 2 };
                    const sorted = res.ips.slice().sort((a, b) => {
                      const ta = (a.type || "other").toLowerCase();
                      const tb = (b.type || "other").toLowerCase();
                      return (order[ta] || 3) - (order[tb] || 3);
                    });
                    sorted.forEach((ip, idx) => {
                      const o = document.createElement("option");
                      o.value = ip.address;
                      o.textContent = `${ip.address} (${ip.interface})`;
                      selectIp.appendChild(o);
                      // Auto-select the first (preferred) address
                      if (idx === 0) selectIp.value = ip.address;
                    });

                    // Try to restore previously saved displayAddress if present
                    try {
                      const cfg = await ipcRenderer.invoke(
                        "get-web-server-config",
                      );
                      if (
                        cfg &&
                        cfg.success &&
                        cfg.config &&
                        cfg.config.displayAddress
                      ) {
                        const saved = cfg.config.displayAddress;
                        // If an option with the saved address exists, select it
                        const opt = Array.from(selectIp.options).find(
                          (o) => o.value === saved,
                        );
                        if (opt) selectIp.value = saved;
                      }
                    } catch (e) {}
                  }
                } catch (e) {
                  console.error(e);
                }
              }

              btn.addEventListener("click", async () => {
                if (modal) modal.style.display = "block";
                await refreshIpsList();
                await refreshStatus();
              });
              if (closeBtn)
                closeBtn.addEventListener("click", () => {
                  if (modal) modal.style.display = "none";
                });
              if (
                refreshIps &&
                typeof refreshIps.addEventListener === "function"
              )
                refreshIps.addEventListener("click", refreshIpsList);

              // Wire autostart checkbox change to persist setting
              try {
                if (autostartCheckbox) {
                  autostartCheckbox.addEventListener("change", async (ev) => {
                    try {
                      const v = !!autostartCheckbox.checked;
                      await ipcRenderer.invoke("set-web-server-autostart", v);
                    } catch (e) {
                      console.error(e);
                    }
                  });
                }
              } catch (e) {}

              if (startStop)
                startStop.addEventListener("click", async () => {
                  try {
                    if (startStop.textContent === "Start") {
                      const addr = (selectIp && selectIp.value) || null;
                      const r = await ipcRenderer.invoke(
                        "start-web-server",
                        addr,
                      );
                      if (r && r.success) {
                        await refreshStatus();
                      } else {
                        alert("Failed to start server: " + (r && r.error));
                      }
                    } else {
                      const r = await ipcRenderer.invoke("stop-web-server");
                      if (r && r.success) {
                        await refreshStatus();
                      } else {
                        alert("Failed to stop server: " + (r && r.error));
                      }
                    }
                  } catch (e) {
                    console.error(e);
                  }
                });

              if (genTls)
                genTls.addEventListener("click", async () => {
                  try {
                    genTls.disabled = true;
                    const r = await ipcRenderer.invoke(
                      "regenerate-web-server-tls",
                    );
                    genTls.disabled = false;
                    if (r && r.success) alert("Generated TLS certs");
                    else alert("Failed to generate TLS: " + (r && r.error));
                  } catch (e) {
                    genTls.disabled = false;
                    console.error(e);
                  }
                });

              if (downloadCa)
                downloadCa.addEventListener("click", async () => {
                  try {
                    const r = await ipcRenderer.invoke("get-ca-cert");
                    if (r && r.success && r.cert) {
                      const blob = new Blob([r.cert], {
                        type: "application/x-pem-file",
                      });
                      const url = URL.createObjectURL(blob);
                      const a = document.createElement("a");
                      a.href = url;
                      a.download = "ca-cert.pem";
                      document.body.appendChild(a);
                      a.click();
                      a.remove();
                      URL.revokeObjectURL(url);
                    } else {
                      alert("CA not found. Generate TLS first.");
                    }
                  } catch (e) {
                    console.error(e);
                  }
                });
            } catch (err) {
              console.error("server modal inner init error", err);
            }
          };

          if (document.readyState === "loading")
            document.addEventListener("DOMContentLoaded", init);
          else init();
        } catch (e) {
          console.error("server modal init error", e);
        }
      })();
    </script>
    <script>
      // Configuration
      const showSettings = false; // Set to false to hide settings button
      const showServer = false; // Set to false to hide Server button

      // Global debug gate and logger wrapper. Set `window.APP_DEBUG = true` in dev console to enable verbose logs.
      window.APP_DEBUG = !!window.APP_DEBUG;
      window.logger = window.logger || {
        log: (...args) => {
          if (window.APP_DEBUG) console.log(...args);
        },
        info: (...args) => {
          if (window.APP_DEBUG) console.info(...args);
        },
        warn: (...args) => {
          if (window.APP_DEBUG) console.warn(...args);
        },
        error: (...args) => {
          // Always show errors
          console.error(...args);
        },
      };

      // Suppress noisy non-error console output in production by default.
      // Developers can enable verbose logs by setting `window.APP_DEBUG = true` in the console.
      if (!window.APP_DEBUG) {
        try {
          console.log = function () {};
          console.info = function () {};
          console.warn = function () {};
        } catch (e) {}
      }

      // Electron preload: require ipcRenderer for backend communication
      const { ipcRenderer } = require("electron");
      const fs = require("node:fs");
      const path = require("node:path");
      // Safe focus helper: only focus visible, enabled elements and respect open modals.
      window.safeFocus = function (elOrId) {
        try {
          const el =
            typeof elOrId === "string"
              ? document.getElementById(elOrId)
              : elOrId;
          if (!el) return false;
          if (el.disabled) return false;
          const style = window.getComputedStyle(el);
          if (
            style.display === "none" ||
            style.visibility === "hidden" ||
            style.opacity === "0"
          )
            return false;
          // If any modal is open, only allow focus if element is inside that modal
          const modals = Array.from(document.querySelectorAll(".modal"));
          for (const m of modals) {
            try {
              if (
                m &&
                m.style &&
                m.style.display &&
                m.style.display !== "none"
              ) {
                if (!m.contains(el)) return false;
              }
            } catch (e) {}
          }
          // Defer to next tick to avoid stealing focus during layout changes
          setTimeout(() => {
            try {
              el.focus();
            } catch (e) {}
          }, 0);
          return true;
        } catch (e) {
          return false;
        }
      };
      // Main application variables
      let masterData = [];
      let masterRawRows = []; // raw rows as read from Excel (arrays)
      let availableHeaders = [];
      let headerInfos = []; // Array of { name, col, norm }
      let currentSelectedRow = null;
      let lastScannedCode = "";
      let scanLogs = [];
      let settings = {
        fields: [], // Array of {id, label, header} objects
        primaryFields: [], // Array of field IDs: first is identifier, others are required verification fields
        scanOperation: "equals",
        displayField: "", // Field ID to display prominently in master modal list
        removedHeaders: [],
        showMultiScanPanel: true,
      };

      // Session state for multi-field verification
      let scanSession = {
        targetPart: null,
        matchedFields: new Set(),
        lastScannedAt: null,
      };

      // Load master data from Excel file (delegates to external implementation)
      async function loadMasterData(forceReload = false) {
        if (typeof window.loadMasterDataExternal === "function") {
          return window.loadMasterDataExternal(forceReload);
        }
        console.warn("loadMasterDataExternal not loaded yet");
        return Promise.resolve();
      }
      // Rebuild input UI dynamically from settings.fields
      function rebuildInputUI() {
        // Safely acquire required DOM nodes
        const inputSection = document.getElementById("input-section");
        const scanByRow = document.getElementById("scan-by-row");
        if (!inputSection || !scanByRow) {
          console.warn("rebuildInputUI: required DOM nodes not found");
          return;
        }

        // Clear existing field rows (except title, scan-by, and verification)
        const existingRows = inputSection.querySelectorAll(
          ".row:not(#scan-by-row)",
        );
        existingRows.forEach((r) => r.remove());

        // Recreate rows from settings.fields
        settings.fields.forEach((field) => {
          const row = document.createElement("div");
          row.className = "row";
          row.id = field.id + "-row";

          const label = document.createElement("label");
          label.setAttribute("for", field.id);
          label.textContent = field.label;

          const input = document.createElement("input");
          input.type = "text";
          input.id = field.id;
          // Preserve current selected row values if available
          try {
            const cur =
              typeof currentSelectedRow !== "undefined"
                ? currentSelectedRow
                : null;
            input.value = cur ? getValueFromRowStrict(cur, field.id) || "" : "";
          } catch (e) {
            input.value = "";
          }
          input.readOnly = true;

          // clicking an input should make it the active scan target
          try {
            input.addEventListener("click", (e) => {
              try {
                // prefer using scanManager if available to keep UI consistent
                if (
                  window.scanManager &&
                  typeof window.scanManager._setManualActiveField === "function"
                ) {
                  window.scanManager._setManualActiveField(field.id);
                  // force using the input value as expected for this manual active field
                  try {
                    window.scanManager.scanSession._forceUseInputValueForActive = true;
                    const el = document.getElementById(field.id);
                    window.scanManager.scanSession._manualExpected = el
                      ? el.value || ""
                      : "";
                  } catch (e) {}
                } else {
                  // fallback: toggle classes locally
                  try {
                    const all = (
                      (window.settings && window.settings.fields) ||
                      []
                    )
                      .map((f) => document.getElementById(f.id))
                      .filter(Boolean);
                    all.forEach((a) => a.classList.remove("scan-active"));
                    input.classList.add("scan-active");
                  } catch (e) {}
                }
              } catch (e) {}
            });
          } catch (e) {}

          row.appendChild(label);
          row.appendChild(input);
          inputSection.insertBefore(row, scanByRow);
        });
      }

      // Lightweight HTML-escape helper (ensure available before usage)
      function escapeHtml(s) {
        try {
          return String(s)
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/\"/g, "&quot;")
            .replace(/'/g, "&#39;");
        } catch (e) {
          return "";
        }
      }

      // Render a failure record box at the bottom of the page showing headers/values and excel row index
      function renderFailureRecordBox(data) {
        try {
          if (!data) return;
          // data: { excelRowIndex, mergedValues, excelRowValues, inputs, scannedRaw, currentField }
          const existing = document.getElementById("failure-record-box");
          let container = existing;
          if (!container) {
            container = document.createElement("div");
            container.id = "failure-record-box";
            // styles
            container.style.position = "fixed";
            container.style.left = "10px";
            container.style.right = "10px";
            container.style.bottom = "10px";
            container.style.background =
              "linear-gradient(180deg, #ff5858, #c62828)";
            container.style.color = "#fff";
            container.style.padding = "12px";
            container.style.borderRadius = "8px";
            container.style.boxShadow = "0 8px 30px rgba(0,0,0,0.5)";
            container.style.zIndex = 9998;
            container.style.maxHeight = "260px";
            container.style.overflow = "auto";
            container.style.fontSize = "13px";
            container.style.lineHeight = "1.3";
            // add close control
            const closeBtn = document.createElement("button");
            closeBtn.textContent = "âœ•";
            closeBtn.style.position = "absolute";
            closeBtn.style.top = "6px";
            closeBtn.style.right = "10px";
            closeBtn.style.background = "transparent";
            closeBtn.style.border = "none";
            closeBtn.style.color = "#fff";
            closeBtn.style.fontSize = "16px";
            closeBtn.style.cursor = "pointer";
            closeBtn.onclick = hideFailureRecordBox;
            container.appendChild(closeBtn);
            document.body.appendChild(container);
          }

          const headerCols = (settings.fields || []).map((f) => ({
            id: f.id,
            header: f.header || f.label || f.id,
            label: f.label || f.id,
          }));

          // Build table
          // Compute display Excel row number (masterRawRows is zero-based, Excel rows start at 1 and have header row)
          let displayExcelRow = "";
          let resolvedRowIdx = null;
          try {
            // If caller provided an excelRowIndex, prefer it (coerce to number)
            if (
              data.excelRowIndex !== null &&
              typeof data.excelRowIndex !== "undefined"
            ) {
              const coerced = Number(data.excelRowIndex);
              if (!Number.isNaN(coerced) && coerced >= 0) {
                resolvedRowIdx = coerced;
              }
            }

            // If not provided or invalid, attempt best-effort lookup
            if (resolvedRowIdx === null) {
              const candidates = data.excelRowValues || data.mergedValues || {};
              if (
                Array.isArray(window.masterRawRows) &&
                (headerInfos || []).length > 0
              ) {
                for (let i = 0; i < window.masterRawRows.length; i++) {
                  const rr = window.masterRawRows[i] || [];
                  let found = false;
                  for (const hi of headerInfos || []) {
                    try {
                      let expectedVal = "";
                      const candKeys = [hi.name, hi.norm, hi.uniqueKey, hi.col];
                      for (const k of candKeys) {
                        try {
                          if (
                            k &&
                            Object.prototype.hasOwnProperty.call(
                              candidates,
                              k,
                            ) &&
                            String(candidates[k] || "").trim() !== ""
                          ) {
                            expectedVal = String(candidates[k] || "").trim();
                            break;
                          }
                        } catch (e) {}
                      }

                      if (!expectedVal && Array.isArray(settings.fields)) {
                        for (const sf of settings.fields) {
                          try {
                            const headerMatch =
                              (sf.header &&
                                (String(sf.header) === String(hi.name) ||
                                  String(sf.header) === String(hi.col) ||
                                  String(sf.header) ===
                                    String(hi.uniqueKey))) ||
                              normalizeHeader(sf.label || "") === hi.norm;
                            if (headerMatch) {
                              const ck = sf.label || sf.id;
                              if (
                                ck &&
                                Object.prototype.hasOwnProperty.call(
                                  candidates,
                                  ck,
                                ) &&
                                String(candidates[ck] || "").trim() !== ""
                              ) {
                                expectedVal = String(
                                  candidates[ck] || "",
                                ).trim();
                                break;
                              }
                            }
                          } catch (e) {}
                        }
                      }

                      if (!expectedVal) continue;
                      const colIndex = headerInfos.indexOf(hi);
                      const cellVal =
                        rr[colIndex] !== undefined && rr[colIndex] !== null
                          ? String(rr[colIndex]).trim()
                          : "";
                      if (
                        cellVal &&
                        String(cellVal) === String(expectedVal).trim()
                      ) {
                        found = true;
                        break;
                      }
                    } catch (e) {}
                  }
                  if (found) {
                    resolvedRowIdx = i;
                    break;
                  }
                }
              }
            }

            // If still unresolved, try a best-effort full-row search for expected or scanned raw values
            if (resolvedRowIdx === null) {
              try {
                const expectedRaw = String(data.expectedRaw || "").trim();
                const scannedRaw = String(data.scannedRaw || "").trim();
                const searchVals = [expectedRaw, scannedRaw]
                  .filter(Boolean)
                  .map((s) =>
                    (s || "").normalize ? s.normalize("NFKC").trim() : s,
                  );
                if (searchVals.length && Array.isArray(window.masterRawRows)) {
                  for (let i = 0; i < window.masterRawRows.length; i++) {
                    const rr = window.masterRawRows[i] || [];
                    try {
                      for (let c = 0; c < rr.length; c++) {
                        const cell =
                          rr[c] !== undefined && rr[c] !== null
                            ? String(rr[c])
                            : "";
                        const normCell = cell.normalize
                          ? cell.normalize("NFKC").trim()
                          : cell.trim();
                        for (const sv of searchVals) {
                          if (!sv) continue;
                          if (normCell === sv) {
                            resolvedRowIdx = i;
                            break;
                          }
                        }
                        if (resolvedRowIdx !== null) break;
                      }
                    } catch (e) {}
                    if (resolvedRowIdx !== null) break;
                  }
                }
              } catch (e) {}

              // Broadcast session update to connected mobile clients (best-effort)
              try {
                const { ipcRenderer } = require("electron");
                try {
                  ipcRenderer.invoke("broadcast-session-update", {
                    selectedRowIndex: window.currentSelectedRowIndex,
                    primaryValue:
                      typeof getPrimaryValue === "function"
                        ? getPrimaryValue(rawRow)
                        : null,
                  });
                } catch (e) {}
              } catch (e) {}
            }

            if (typeof resolvedRowIdx === "number" && resolvedRowIdx >= 0) {
              // Excel row number = zero-based index in masterRawRows + 1 (1-based) + header row
              displayExcelRow = String(resolvedRowIdx + 2);
            } else {
              displayExcelRow = "";
            }
          } catch (e) {
            displayExcelRow = "";
            resolvedRowIdx = null;
          }

          // Display header with bracketed Excel row number when available
          const headerDisplay = displayExcelRow
            ? `Failed to scan record - Excel row number - (${displayExcelRow})`
            : `Failed to scan record - Excel row number - (unknown)`;
          let html = `<div style="font-weight:700; margin-bottom:8px;">${headerDisplay}</div>`;
          // Prominently show expected vs scanned raw values for quick operator diagnosis
          try {
            const exp = escapeHtml(String(data.expectedRaw || ""));
            const sc = escapeHtml(String(data.scannedRaw || ""));
            if (exp || sc) {
              html += `<div style="display:flex;gap:12px;margin-bottom:8px;font-size:14px;">
                <div style="flex:1;">
                  <div style="opacity:0.9;font-weight:600">Expected (raw)</div>
                  <div style="margin-top:6px;padding:6px;border-radius:6px;background:rgba(255,255,255,0.06);">${exp}</div>
                </div>
                <div style="flex:1;">
                  <div style="opacity:0.9;font-weight:600">Scanned (raw)</div>
                  <div style="margin-top:6px;padding:6px;border-radius:6px;background:rgba(255,255,255,0.06);">${sc}</div>
                </div>
              </div>`;
            }
          } catch (e) {}
          html +=
            '<div style="overflow:auto"><table style="width:100%; border-collapse:collapse;"> <thead><tr>';
          headerCols.forEach((hc) => {
            html += `<th style="text-align:left; padding:6px 8px; border-bottom:1px solid rgba(255,255,255,0.15);">${hc.header}</th>`;
          });
          html +=
            '<th style="text-align:left; padding:6px 8px; border-bottom:1px solid rgba(255,255,255,0.15);">scan-by</th>';
          html +=
            '<th style="text-align:left; padding:6px 8px; border-bottom:1px solid rgba(255,255,255,0.15);">Scanned Code</th>';
          html +=
            '<th style="text-align:left; padding:6px 8px; border-bottom:1px solid rgba(255,255,255,0.15);">Status</th>';
          html += "</tr></thead><tbody><tr>";

          // For each header column, try mergedValues[label] -> mergedValues[header] -> excelRowValues[header] -> inputs[label]
          const merged = data.mergedValues || {};
          const excelVals = data.excelRowValues || {};
          const inputs = data.inputs || {};
          headerCols.forEach((hc) => {
            let v = "";
            try {
              if (merged.hasOwnProperty(hc.label)) v = merged[hc.label];
              else if (merged.hasOwnProperty(hc.header)) v = merged[hc.header];
              else if (merged.hasOwnProperty(hc.id)) v = merged[hc.id];
              else if (excelVals.hasOwnProperty(hc.header))
                v = excelVals[hc.header];
              else if (excelVals.hasOwnProperty(hc.label))
                v = excelVals[hc.label];
              else if (inputs.hasOwnProperty(hc.label)) v = inputs[hc.label];
              else v = "";
            } catch (e) {
              v = "";
            }
            // If this column corresponds to the failed/current field, apply a high-contrast highlight
            let cellStyle =
              "padding:6px 8px; border-top:1px solid rgba(255,255,255,0.06);";
            let cellAttrs = "";
            try {
              if (
                data &&
                data.currentField &&
                String(data.currentField) === String(hc.id)
              ) {
                // High-contrast highlight: light yellow background with dark text for visibility inside the red box
                cellStyle +=
                  " background:#fff59d; color:#000; font-weight:700; border-radius:4px;";
                cellAttrs = ` data-unmatched-field="1"`;
              }
            } catch (e) {}
            html += `<td${cellAttrs} style="${cellStyle}">${String(
              v || "",
            )}</td>`;
          });

          // scan-by, scanned code, status
          const scanBy =
            (data.mergedValues && data.mergedValues["scan-by"]) ||
            (document.getElementById("scan-by")
              ? document.getElementById("scan-by").value
              : "") ||
            "";
          const scanned = data.scannedRaw || "";
          const status = "NOT_MATCHED";
          html += `<td style="padding:6px 8px; border-top:1px solid rgba(255,255,255,0.06);">${escapeHtml(
            String(scanBy || ""),
          )}</td>`;
          html += `<td style="padding:6px 8px; border-top:1px solid rgba(255,255,255,0.06);">${escapeHtml(
            String(data.scannedRaw || ""),
          )}</td>`;
          html += `<td style="padding:6px 8px; border-top:1px solid rgba(255,255,255,0.06);">${status}</td>`;

          html += "</tr></tbody></table></div>";

          // Add NOT_MATCH diagnostic block showing expected vs scanned raw values and matched column info
          try {
            const expectedRaw = data.expectedRaw || "";
            const scannedRawDiag = data.scannedRaw || "";
            const expectedNorm = (function (s) {
              try {
                return String(s || "")
                  .normalize("NFKC")
                  .trim();
              } catch (e) {
                return String(s || "");
              }
            })(expectedRaw);
            const scannedNorm = (function (s) {
              try {
                return String(s || "")
                  .normalize("NFKC")
                  .trim();
              } catch (e) {
                return String(s || "");
              }
            })(scannedRawDiag);

            // determine matched header/column for expected value
            let matchedHeader = "";
            let matchedCol = "";
            try {
              const expTrim = String(expectedRaw || "").trim();
              if (expTrim) {
                for (const hc of headerCols) {
                  try {
                    const v = excelVals[hc.header] || merged[hc.header] || "";
                    if (String(v || "").trim() === expTrim) {
                      matchedHeader = hc.header || "";
                      break;
                    }
                  } catch (e) {}
                }
                if (!matchedHeader) {
                  const normExp = (function (s) {
                    try {
                      return String(s || "")
                        .normalize("NFKC")
                        .replace(/\s+/g, " ")
                        .trim();
                    } catch (e) {
                      return String(s || "");
                    }
                  })(expTrim);
                  for (const hi of headerInfos || []) {
                    try {
                      const v = excelVals[hi.name] || merged[hi.name] || "";
                      const vNorm = String(v || "").normalize
                        ? String(v || "")
                            .normalize("NFKC")
                            .replace(/\s+/g, " ")
                            .trim()
                        : String(v || "");
                      if (vNorm === normExp) {
                        matchedHeader = hi.name || "";
                        matchedCol = hi.col || "";
                        break;
                      }
                    } catch (e) {}
                  }
                } else {
                  const foundHi = (headerInfos || []).find(
                    (h) =>
                      h.name === matchedHeader ||
                      h.norm === normalizeHeader(matchedHeader),
                  );
                  if (foundHi) matchedCol = foundHi.col || "";
                }
              }
            } catch (e) {}

            html += `<div style="margin-top:8px;padding-top:8px;border-top:1px solid rgba(255,255,255,0.08);font-size:12px;color:#fff;">`;
            html += `<div style="font-weight:700; margin-bottom:6px;">NOT_MATCH Diagnostic</div>`;
            html += `<div style="display:flex;gap:12px;flex-wrap:wrap;"><div style="flex:1"><div style="opacity:0.9;font-weight:600">Expected (raw)</div><div style="margin-top:4px">${escapeHtml(
              String(expectedRaw || ""),
            )}</div></div>`;
            html += `<div style="flex:1"><div style="opacity:0.9;font-weight:600">Scanned (raw)</div><div style="margin-top:4px">${escapeHtml(
              String(scannedRawDiag || ""),
            )}</div></div></div>`;
            html += `<div style="margin-top:6px;opacity:0.85;font-size:11px">Normalized Expected: ${escapeHtml(
              expectedNorm,
            )}</div>`;
            html += `<div style="opacity:0.85;font-size:11px">Normalized Scanned: ${escapeHtml(
              scannedNorm,
            )}</div>`;
            html += `<div style="margin-top:6px;font-size:12px;font-weight:700">Matched Column: ${escapeHtml(
              matchedHeader || "â€”",
            )} ${matchedCol ? "(" + escapeHtml(matchedCol) + ")" : ""}</div>`;
            html += `</div>`;
          } catch (e) {}

          // Inject glowing highlight CSS for the unmatched cell (only once)
          try {
            if (!document.getElementById("failure-box-glow-style")) {
              const s = document.createElement("style");
              s.id = "failure-box-glow-style";
              s.textContent = `
                /* Uniform four-side pulsing glow */
                #failure-record-box td[data-unmatched-field="1"] {
                  animation: failureGlow 1.6s ease-in-out infinite;
                  /* Use a large spread and blur to create even glow around all sides */
                  box-shadow: 0 0 18px 8px rgba(255,230,0,0.85), 0 0 0 4px rgba(255,230,0,0.18) inset;
                  border-radius: 6px;
                }
                @keyframes failureGlow {
                  0% {
                    box-shadow: 0 0 8px 4px rgba(255,230,0,0.20), 0 0 0 2px rgba(255,230,0,0.06) inset;
                  }
                  50% {
                    box-shadow: 0 0 28px 12px rgba(255,230,0,0.95), 0 0 0 4px rgba(255,230,0,0.12) inset;
                  }
                  100% {
                    box-shadow: 0 0 8px 4px rgba(255,230,0,0.20), 0 0 0 2px rgba(255,230,0,0.06) inset;
                  }
                }
              `;
              document.head.appendChild(s);
            }
          } catch (e) {}

          container.innerHTML = html;
          // store last failure context so successful re-scan of the same row can clear it
          try {
            window._lastFailureRecord = window._lastFailureRecord || {};
            window._lastFailureRecord.excelRowIndex =
              typeof resolvedRowIdx === "number" && resolvedRowIdx >= 0
                ? resolvedRowIdx
                : null;
            try {
              const primaryId =
                (settings &&
                  settings.primaryFields &&
                  settings.primaryFields[0]) ||
                (settings &&
                  settings.fields &&
                  settings.fields[0] &&
                  settings.fields[0].id) ||
                null;
              let primaryHeader = "";
              if (primaryId) {
                const pf = (settings.fields || []).find(
                  (ff) => ff.id === primaryId,
                );
                primaryHeader = (pf && (pf.header || pf.label || pf.id)) || "";
              }
              const primaryVal =
                (merged && (merged[primaryHeader] || merged[primaryId])) ||
                (excelVals &&
                  (excelVals[primaryHeader] || excelVals[primaryId])) ||
                "";
              window._lastFailureRecord.primaryValue = primaryVal || null;
            } catch (e) {
              window._lastFailureRecord.primaryValue = null;
            }
            window._lastFailureRecord.currentField =
              data && data.currentField ? data.currentField : null;
          } catch (e) {}
          // re-append close button
          const closeBtn2 = document.createElement("button");
          closeBtn2.textContent = "âœ•";
          closeBtn2.style.position = "absolute";
          closeBtn2.style.top = "6px";
          closeBtn2.style.right = "10px";
          closeBtn2.style.background = "transparent";
          closeBtn2.style.border = "none";
          closeBtn2.style.color = "#fff";
          closeBtn2.style.fontSize = "16px";
          closeBtn2.style.cursor = "pointer";
          closeBtn2.onclick = hideFailureRecordBox;
          container.appendChild(closeBtn2);
        } catch (e) {
          console.error("renderFailureRecordBox error", e);
        }
      }

      function hideFailureRecordBox() {
        try {
          const el = document.getElementById("failure-record-box");
          try {
            if (el) el.remove();
          } catch (e) {}
          try {
            if (window._lastFailureRecord) window._lastFailureRecord = null;
          } catch (e) {}
        } catch (e) {}
      }

      // Try to clear the failure box if the current selection/scan corresponds to the last failure
      function tryClearFailureBoxForCurrentScan() {
        try {
          const last = window._lastFailureRecord || null;
          if (!last) return false;

          // Resolve current selection primary value and master row index
          const pid =
            (settings && settings.primaryFields && settings.primaryFields[0]) ||
            (settings &&
              settings.fields &&
              settings.fields[0] &&
              settings.fields[0].id) ||
            null;
          let currentPrimary = null;
          let currentRowIdx = null;

          try {
            if (currentSelectedRow) {
              if (Array.isArray(currentSelectedRow)) {
                currentRowIdx = Array.isArray(masterRawRows)
                  ? masterRawRows.findIndex((r) => r === currentSelectedRow)
                  : null;
                if (currentRowIdx === -1) currentRowIdx = null;
                if (pid)
                  currentPrimary =
                    getValueFromRow(currentSelectedRow, pid) || null;
              } else {
                if (pid) {
                  currentPrimary =
                    getValueFromRow(currentSelectedRow, pid) || null;
                  if (Array.isArray(masterRawRows)) {
                    currentRowIdx = masterRawRows.findIndex((r) => {
                      try {
                        return (
                          (typeof getValueFromRow === "function"
                            ? getValueFromRow(r, pid)
                            : "") === currentPrimary
                        );
                      } catch (e) {
                        return false;
                      }
                    });
                    if (currentRowIdx === -1) currentRowIdx = null;
                  }
                }
              }
            } else if (pid) {
              // fallback: read primary from input DOM
              const inp = document.getElementById(pid);
              if (inp) {
                currentPrimary = inp.value || null;
                if (currentPrimary && Array.isArray(masterRawRows)) {
                  currentRowIdx = masterRawRows.findIndex((r) => {
                    try {
                      return (
                        (typeof getValueFromRow === "function"
                          ? getValueFromRow(r, pid)
                          : "") === currentPrimary
                      );
                    } catch (e) {
                      return false;
                    }
                  });
                  if (currentRowIdx === -1) currentRowIdx = null;
                }
              }
            }
          } catch (e) {}

          // Compare to last failure: prefer excelRowIndex when present, otherwise compare primaryValue
          if (
            typeof last.excelRowIndex === "number" &&
            last.excelRowIndex >= 0 &&
            typeof currentRowIdx === "number"
          ) {
            if (last.excelRowIndex === currentRowIdx) {
              hideFailureRecordBox();
              return true;
            }
          }
          if (last.primaryValue && currentPrimary) {
            try {
              if (
                String(last.primaryValue).trim() ===
                String(currentPrimary).trim()
              ) {
                hideFailureRecordBox();
                return true;
              }
            } catch (e) {}
          }

          return false;
        } catch (e) {
          return false;
        }
      }

      // Helper: get value from master row using field ID
      // Supports both object-mapped rows and raw array rows from Excel
      function getValueFromRow(row, fieldId) {
        const field = settings.fields.find((f) => f.id === fieldId);
        if (!field) return "";

        // If row is an array (raw Excel row), use headerInfos to locate column index
        if (Array.isArray(row)) {
          // If headerCol is present (like 'G'), find its index in headerInfos
          let colIndex = -1;
          if (field.headerCol) {
            colIndex = (headerInfos || []).findIndex(
              (h) => h.col === field.headerCol,
            );
          }
          // If not found, try to match by header name or normalized header
          if (colIndex === -1 && field.header) {
            const desiredNorm = normalizeHeader(field.header || "");
            const matchedHi = (headerInfos || []).find(
              (h) => h.name === field.header || h.norm === desiredNorm,
            );
            if (matchedHi) colIndex = headerInfos.indexOf(matchedHi);
          }
          // Last resort: try to find by label heuristics
          if (colIndex === -1 && field.label) {
            const labNorm = normalizeHeader(field.label || "");
            const matchedHi = (headerInfos || []).find(
              (h) =>
                normalizeHeader(h.name || "") === labNorm ||
                normalizeHeader(h.name || "").includes(labNorm),
            );
            if (matchedHi) colIndex = headerInfos.indexOf(matchedHi);
          }

          if (
            colIndex >= 0 &&
            row[colIndex] !== undefined &&
            row[colIndex] !== null
          ) {
            const v = String(row[colIndex] || "").trim();
            if (v) return v;
          }

          // Fallback: scan headerInfos for any matching keys and return first non-empty
          for (let i = 0; i < (headerInfos || []).length; i++) {
            const hi = headerInfos[i];
            if (!hi) continue;
            if (row[i] !== undefined && row[i] !== null) {
              const v = String(row[i] || "").trim();
              if (v) return v;
            }
          }

          return "";
        }

        // Otherwise assume row is an object mapping (legacy behavior)
        try {
          // Prefer lookup by column address if available
          if (field.headerCol && row[field.headerCol] !== undefined) {
            const v = String(row[field.headerCol] || "").trim();
            if (v) return v;
          }

          // Exact header name match and robust fallback using headerInfos uniqueKey
          if (field.header) {
            const desiredNorm = normalizeHeader(field.header || "");
            let matchedHi = null;
            if (field.headerCol)
              matchedHi = (headerInfos || []).find(
                (h) => h.col === field.headerCol,
              );
            if (!matchedHi)
              matchedHi = (headerInfos || []).find(
                (h) => h.name === field.header || h.norm === desiredNorm,
              );
            if (!matchedHi && field.label) {
              const labNorm = normalizeHeader(field.label || "");
              matchedHi = (headerInfos || []).find(
                (h) =>
                  normalizeHeader(h.name || "") === labNorm ||
                  normalizeHeader(h.name || "").includes(labNorm),
              );
            }

            if (matchedHi) {
              const tryKeys = [
                matchedHi.uniqueKey,
                matchedHi.col,
                matchedHi.name,
                matchedHi.norm,
              ];
              for (const k of tryKeys) {
                if (k && row.hasOwnProperty(k)) {
                  const v = String(row[k] || "").trim();
                  if (v) return v;
                }
              }
            } else {
              if (row.hasOwnProperty(field.header)) {
                const v = String(row[field.header] || "").trim();
                if (v) return v;
              }
              const normKey = normalizeHeader(field.header || "");
              if (normKey && row.hasOwnProperty(normKey)) {
                const v = String(row[normKey] || "").trim();
                if (v) return v;
              }
            }
          }

          for (const hi of headerInfos || []) {
            const keys = [hi.col, hi.name, hi.norm];
            for (const k of keys) {
              if (k && row.hasOwnProperty(k)) {
                const v = String(row[k] || "").trim();
                if (v) return v;
              }
            }
          }
        } catch (e) {
          // ignore
        }

        return "";
      }

      // Strict lookup: prefer headerCol or exact header/uniqueKey matches only.
      // This avoids loose label-based heuristics and prevents duplicate values
      // when headers have similar names.
      function getValueFromRowStrict(row, fieldId) {
        const field = settings.fields.find((f) => f.id === fieldId);
        if (!field) return "";
        try {
          if (field.headerCol && row[field.headerCol] !== undefined) {
            return String(row[field.headerCol] || "").trim();
          }
          if (field.header) {
            const desiredNorm = normalizeHeader(field.header || "");
            const matchedHi = (headerInfos || []).find(
              (h) => h.name === field.header || h.norm === desiredNorm,
            );
            if (matchedHi) {
              if (
                matchedHi.uniqueKey &&
                row.hasOwnProperty(matchedHi.uniqueKey)
              )
                return String(row[matchedHi.uniqueKey] || "").trim();
              if (row.hasOwnProperty(matchedHi.col))
                return String(row[matchedHi.col] || "").trim();
              if (row.hasOwnProperty(matchedHi.name))
                return String(row[matchedHi.name] || "").trim();
              if (row.hasOwnProperty(matchedHi.norm))
                return String(row[matchedHi.norm] || "").trim();
            }
            if (row.hasOwnProperty(field.header))
              return String(row[field.header] || "").trim();
            const nk = normalizeHeader(field.header || "");
            if (nk && row.hasOwnProperty(nk))
              return String(row[nk] || "").trim();
          }
        } catch (e) {
          /* best-effort */
        }
        return "";
      }

      // Normalize header keys for robust lookup (handles Unicode variants, extra spaces, etc.)
      function normalizeHeader(h) {
        if (!h && h !== "") return h;
        try {
          return String(h).normalize("NFKC").replace(/\s+/g, " ").trim();
        } catch (e) {
          return String(h || "").trim();
        }
      }

      // Convert zero-based column index to Excel-style column letters (0 -> A, 26 -> AA)
      function columnLetter(index) {
        let n = Number(index);
        if (!Number.isFinite(n) || n < 0) return "";
        let s = "";
        while (n >= 0) {
          s = String.fromCodePoint((n % 26) + 65) + s;
          n = Math.floor(n / 26) - 1;
        }
        return s;
      }

      // Helper: get primary field value from row
      function getPrimaryFieldId() {
        return (settings.primaryFields && settings.primaryFields[0]) || "";
      }

      // Helper: get primary field value from row (first primary field)
      function getPrimaryValue(row) {
        const primaryId = getPrimaryFieldId();
        if (!primaryId) return "";
        return getValueFromRow(row, primaryId);
      }

      // Find part details from master data using primary field value
      function findPartDetails(primaryValue) {
        const primaryId = getPrimaryFieldId();
        if (!primaryId) return null;
        return masterData.find((item) => {
          try {
            const v = getValueFromRow(item, primaryId) || "";
            return String(v) === String(primaryValue);
          } catch (e) {
            return false;
          }
        });
      }

      // Load settings from `settings.json` if available, otherwise keep defaults
      function loadSettings() {
        try {
          if (!fs.existsSync("settings.json")) {
            console.log("settings.json not found, using defaults");
            return;
          }
          const raw = fs.readFileSync("settings.json", "utf8").trim();
          if (!raw) return;
          let parsed = {};
          try {
            parsed = JSON.parse(raw);
          } catch (e) {
            console.warn("Failed to parse settings.json, ignoring:", e);
            return;
          }

          // Basic merge: only replace known keys to avoid corrupting structure
          if (Array.isArray(parsed.fields)) settings.fields = parsed.fields;
          // Support legacy single-primary key 'primaryField' as well as new 'primaryFields' array
          if (Array.isArray(parsed.primaryFields)) {
            settings.primaryFields = parsed.primaryFields;
          } else if (parsed.primaryField) {
            settings.primaryFields = [parsed.primaryField];
          }
          // Support multiple display fields (new) or legacy single `displayField`
          if (Array.isArray(parsed.displayFields)) {
            settings.displayFields = parsed.displayFields;
          } else if (parsed.displayField) {
            settings.displayFields = [parsed.displayField];
          }
          // Load persisted grouping fields if present
          if (Array.isArray(parsed.groupingFields)) {
            settings.groupingFields = parsed.groupingFields;
          }
          if (parsed.scanOperation)
            settings.scanOperation = parsed.scanOperation;
          if (parsed.displayField) settings.displayField = parsed.displayField;

          // Support toggling the multi-scan panel visibility
          if (typeof parsed.showMultiScanPanel !== "undefined") {
            settings.showMultiScanPanel = !!parsed.showMultiScanPanel;
          }

          // Support removed/hidden headers list
          if (Array.isArray(parsed.removedHeaders))
            settings.removedHeaders = parsed.removedHeaders;

          // Ensure fields have ids
          settings.fields = (settings.fields || []).map((f, idx) => {
            return {
              id: f.id || `field_${idx}`,
              label: f.label || "Field",
              header: f.header || "",
              headerCol: f.headerCol || "",
              ...f,
            };
          });

          // Normalize removed headers entries
          settings.removedHeaders = (settings.removedHeaders || []).map(
            (h) => ({
              name: h.name || "",
              col: h.col || "",
              norm: normalizeHeader(h.name || ""),
              ...h,
            }),
          );

          console.log("Settings loaded:", settings);
          // Apply persisted UI controls immediately so visibility is consistent across restarts
          try {
            const chk = document.getElementById("show-multi-scan-panel");
            if (chk)
              chk.checked =
                typeof settings.showMultiScanPanel === "undefined"
                  ? true
                  : !!settings.showMultiScanPanel;
            const panel = document.getElementById("multi-scan-panel");
            if (panel)
              panel.style.display =
                settings.showMultiScanPanel === false ? "none" : "block";
          } catch (e) {
            console.error(
              "Failed to apply showMultiScanPanel to UI elements",
              e,
            );
          }
          // Respect developer config to hide/show the server button
          try {
            const serverBtn = document.getElementById("btn-start-server");
            if (serverBtn) serverBtn.style.display = showServer ? "" : "none";
            const updateMasterNavBtn =
              document.getElementById("btn-update-master");
            if (updateMasterNavBtn)
              updateMasterNavBtn.style.display = showServer ? "" : "none";
          } catch (e) {}
        } catch (error) {
          console.error("Error loading settings:", error);
        }
      }

      // Save current settings to `settings.json`
      function saveSettings() {
        try {
          const out = {
            fields: settings.fields || [],
            primaryFields: settings.primaryFields || [],
            scanOperation: settings.scanOperation || "equals",
            displayField: settings.displayField || "",
            displayFields: settings.displayFields || [],
            removedHeaders: settings.removedHeaders || [],
            showMultiScanPanel: !!settings.showMultiScanPanel,
            groupingFields: Array.isArray(settings.groupingFields)
              ? settings.groupingFields
              : [],
          };
          fs.writeFileSync(
            "settings.json",
            JSON.stringify(out, null, 2),
            "utf8",
          );
          console.log("Settings saved to settings.json");
        } catch (error) {
          console.error("Error saving settings:", error);
        }
      }

      // Flag to prevent multiple simultaneous saves
      let isSaving = false;
      let currentLogDate = new Date().toISOString().split("T")[0]; // Track current log date

      // Function to load scan logs from today's date file
      async function loadTodaysScanLogs() {
        try {
          const today = new Date().toISOString().split("T")[0];
          console.log("Loading scan logs for date:", today);

          // Call backend to read today's scan logs
          const logsData = await ipcRenderer.invoke("read-logs", {
            date: today,
          });

          if (!logsData || !Array.isArray(logsData)) {
            console.log("No logs found for today or invalid data format");
            return [];
          }

          // Convert the loaded data back to log entry format
          // Determine which header represents the primary/display field
          const displayFieldId =
            settings.displayField || (settings.primaryFields || [])[0] || "";
          const displayHeader =
            (settings.fields || []).find((f) => f.id === displayFieldId)
              ?.header || "Part Code";

          const loadedLogs = logsData.map((logData) => {
            const dateStr = String(logData["Date"] || "");
            const timeStr = String(logData["Time"] || "");
            const timestamp = new Date(
              (dateStr ? dateStr.split("/").reverse().join("-") : "") +
                " " +
                (timeStr || ""),
            );

            // Resolve common fields using configured header names first, then legacy keys
            const partCode =
              logData[displayHeader] || logData["Part Code"] || "";
            const partName = logData["Part Name"] || "";
            const customer = logData["Customer"] || "";
            const scannedCode = logData["Scanned Code"] || "";
            const scannerInfo = logData["scan-by"] || logData["Scanner"] || "";
            const matchStatus = logData["Status"] || "UNKNOWN";

            const log = {
              timestamp,
              partCode,
              partName,
              customer,
              scannedCode,
              scannerInfo,
              matchStatus,
              raw: logData,
            };

            // If customer is empty in the log, try to get it from current master data
            if (!log.customer && log.partCode) {
              const partDetails = findPartDetails(log.partCode);
              if (partDetails) {
                const c = getValueFromRow(partDetails, "Customer");
                if (c) log.customer = c;
              }
            }

            return log;
          });

          console.log(`Loaded ${loadedLogs.length} logs from today's file`);
          return loadedLogs;
        } catch (error) {
          console.error("Error loading today's scan logs:", error);
          showNotification(
            "Error loading scan history. Please try again.",
            "error",
          );
          return [];
        }
      }

      // Function to save a single scan log entry in real-time
      async function saveScanLogRealtime(logEntry) {
        console.log("saveScanLogRealtime called with:", logEntry);

        if (isSaving) {
          console.log("Already saving, queuing this save...");
          // Wait a bit and retry
          setTimeout(() => saveScanLogRealtime(logEntry), 100);
          return;
        }

        isSaving = true;

        try {
          // Check if date has changed (new day started)
          const today = new Date().toISOString().split("T")[0];
          if (today !== currentLogDate) {
            console.log("Date changed from", currentLogDate, "to", today);
            currentLogDate = today;
          }

          // Prepare single log entry for saving using configured fields
          const logToSave = {};
          logToSave["Date"] = logEntry.timestamp.toLocaleDateString("en-GB");
          logToSave["Time"] = logEntry.timestamp.toLocaleTimeString("en-GB");

          // Include configured fields using their header names - prefer values from logEntry (if present),
          // then master data (currentSelectedRow), then DOM inputs.
          (settings.fields || []).forEach((f) => {
            const header = f.header || f.label || f.id;
            try {
              let val = "";
              if (logEntry && logEntry[header] !== undefined) {
                val = logEntry[header] || "";
              }
              if (!val && currentSelectedRow) {
                val = getValueFromRow(currentSelectedRow, f.id) || "";
              }
              if (!val) {
                const el = document.getElementById(f.id);
                val = el ? el.value || "" : "";
              }
              logToSave[header] = val;
            } catch (e) {
              logToSave[header] = "";
            }
          });

          // Add scan-by value as an explicit column (preserve the key as-is)
          try {
            logToSave["scan-by"] = document.getElementById("scan-by")
              ? document.getElementById("scan-by").value
              : logEntry.scannerInfo || "";
          } catch (e) {
            logToSave["scan-by"] = logEntry.scannerInfo || "";
          }

          // Add legacy/common columns (prefer explicit keys on logEntry if present)
          logToSave["Scanned Code"] =
            logEntry && logEntry["Scanned Code"] !== undefined
              ? logEntry["Scanned Code"]
              : logEntry.scannedCode || "";
          logToSave["Scanner"] =
            logEntry && logEntry["Scanner"] !== undefined
              ? logEntry["Scanner"]
              : logEntry.scannerInfo || "";
          logToSave["Status"] =
            logEntry && logEntry["Status"] !== undefined
              ? logEntry["Status"]
              : logEntry.matchStatus || "";

          console.log("Saving log entry to Excel:", logToSave);

          // Save single log entry using IPC with date-based filename
          const result = await ipcRenderer.invoke("write-single-log", {
            log: logToSave,
            date: currentLogDate,
          });

          console.log("Log saved successfully to:", result.filePath);
        } catch (error) {
          console.error("Error saving log in real-time:", error);
          showNotification("Warning: Failed to save scan log to file", "error");
        } finally {
          isSaving = false;
        }
      }

      // Function to save a single error scan log entry in real-time
      async function saveErrorScanLogRealtime(logEntry) {
        console.log("saveErrorScanLogRealtime called with:", logEntry);

        if (isSaving) {
          console.log("Already saving, queuing this save...");
          setTimeout(() => saveErrorScanLogRealtime(logEntry), 100);
          return;
        }

        isSaving = true;

        try {
          const today = new Date().toISOString().split("T")[0];
          if (today !== currentLogDate) {
            currentLogDate = today;
          }

          const logToSave = {};
          logToSave["Date"] = logEntry.timestamp.toLocaleDateString("en-GB");
          logToSave["Time"] = logEntry.timestamp.toLocaleTimeString("en-GB");

          // Include configured fields using their header names - prefer values from logEntry (if present), then DOM inputs
          (settings.fields || []).forEach((f) => {
            const header = f.header || f.label || f.id;
            try {
              if (logEntry && logEntry[header] !== undefined) {
                logToSave[header] = logEntry[header] || "";
              } else {
                logToSave[header] = document.getElementById(f.id)
                  ? document.getElementById(f.id).value
                  : "";
              }
            } catch (e) {
              logToSave[header] = "";
            }
          });

          // Add scan-by value as an explicit column (preserve the key as-is)
          try {
            logToSave["scan-by"] = document.getElementById("scan-by")
              ? document.getElementById("scan-by").value
              : logEntry.scannerInfo || "";
          } catch (e) {
            logToSave["scan-by"] = logEntry.scannerInfo || "";
          }

          // Add legacy/common columns (prefer explicit keys on logEntry if present)
          logToSave["Scanned Code"] =
            logEntry && logEntry["Scanned Code"] !== undefined
              ? logEntry["Scanned Code"]
              : logEntry.scannedCode || "";
          logToSave["Scanner"] =
            logEntry && logEntry["Scanner"] !== undefined
              ? logEntry["Scanner"]
              : logEntry.scannerInfo || "";
          logToSave["Status"] =
            logEntry && logEntry["Status"] !== undefined
              ? logEntry["Status"]
              : logEntry.matchStatus || "";

          console.log("Saving error log entry to Excel:", logToSave);

          const result = await ipcRenderer.invoke("write-single-log", {
            log: logToSave,
            date: "error-" + currentLogDate,
          });

          console.log("Error log saved successfully to:", result.filePath);
        } catch (error) {
          console.error("Error saving error log in real-time:", error);
          showNotification(
            "Warning: Failed to save error scan log to file",
            "error",
          );
        } finally {
          isSaving = false;
        }
      }

      // Function to save all logs to Excel (for manual export)
      async function saveLogsToExcel() {
        try {
          const todaysLogs = await loadTodaysScanLogs();
          if (!Array.isArray(todaysLogs) || todaysLogs.length === 0) {
            showNotification("No scan logs available for today", "error");
            return;
          }

          const logsToSave = todaysLogs.map((log) => {
            const row = {};
            row["Date"] = log.timestamp.toLocaleDateString("en-GB");
            row["Time"] = log.timestamp.toLocaleTimeString("en-GB");

            // Include configured fields using header names (take from log.raw if present)
            (settings.fields || []).forEach((f) => {
              const header = f.header || f.label || f.id;
              // Prefer raw saved value, otherwise attempt to read from currentSelectedRow if available
              row[header] =
                (log.raw && log.raw[header]) ||
                (currentSelectedRow
                  ? getValueFromRow(currentSelectedRow, f.id)
                  : "") ||
                "";
            });

            // Ensure scan-by is present
            row["scan-by"] =
              (log.raw && (log.raw["scan-by"] || log.raw["Scanner"])) ||
              log.scannerInfo ||
              "";

            // Legacy/common columns
            row["Scanned Code"] = log.scannedCode;
            row["Scanner"] = log.scannerInfo;
            row["Status"] = log.matchStatus;
            return row;
          });

          // Sort by date/time descending
          logsToSave.sort((a, b) => {
            const dateA = new Date(
              a.Date.split("/").reverse().join("-") + " " + a.Time,
            );
            const dateB = new Date(
              b.Date.split("/").reverse().join("-") + " " + b.Time,
            );
            return dateB - dateA;
          });

          const result = await ipcRenderer.invoke("write-logs", logsToSave);
          console.log(
            `Successfully saved ${logsToSave.length} logs to ${result.filePath}`,
          );
          showNotification(
            `Successfully exported ${logsToSave.length} scan logs`,
            "info",
          );
        } catch (error) {
          console.error("Error in saveLogsToExcel:", error);
          showNotification("Error exporting logs. Please try again.", "error");
        }
      }

      // Handle scanned input
      async function handleScan(scannedCode) {
        console.log("handleScan called with:", scannedCode);

        // Optionally reload master data from disk before each scan if configured
        try {
          const shouldForceReload = !!(settings && settings.forceReloadOnScan);
          if (shouldForceReload) {
            await loadMasterData(true);
          }
        } catch (e) {
          console.warn("Master reload before scan failed:", e);
        }

        // If multiple primary fields are configured, delegate to scanManager
        if (
          Array.isArray(settings.primaryFields) &&
          settings.primaryFields.length > 1 &&
          window.scanManager &&
          typeof window.scanManager.handleScan === "function"
        ) {
          try {
            return window.scanManager.handleScan(scannedCode);
          } catch (e) {
            console.error("scanManager.handleScan error:", e);
          }
        }

        try {
          // Clean the scanned code
          const cleanedCode = scannedCode;
          console.log("Cleaned code:", cleanedCode);

          if (!cleanedCode) {
            console.log("Empty code after cleaning, ignoring");
            return;
          }

          // Determine expected value from the currently selected master row or fallback to primary field input
          let expectedValue = "";
          if (currentSelectedRow) {
            expectedValue = getPrimaryValue(currentSelectedRow);
          } else {
            const primaryInput = document.getElementById(getPrimaryFieldId());
            expectedValue = primaryInput ? primaryInput.value : "";
          }

          console.log(
            "Comparing scanned code:",
            cleanedCode,
            "with expected value:",
            expectedValue,
          );

          // Apply scan operation configured in settings (normalized, case-insensitive)
          let isMatch = false;
          const op = settings.scanOperation || "equals";
          const normalize = (s) => {
            try {
              return String(s || "")
                .normalize("NFKC")
                .trim()
                .toLowerCase();
            } catch (e) {
              return String(s || "")
                .trim()
                .toLowerCase();
            }
          };
          try {
            if (op === "regex") {
              try {
                const re = new RegExp(expectedValue, "i");
                isMatch = re.test(String(cleanedCode || ""));
              } catch (reErr) {
                isMatch = normalize(cleanedCode) === normalize(expectedValue);
              }
            } else {
              const a = normalize(cleanedCode);
              const b = normalize(expectedValue);
              if (op === "equals") isMatch = a === b;
              else if (op === "contains")
                isMatch = a.includes(b) || b.includes(a);
              else if (op === "startsWith")
                isMatch = a.startsWith(b) || b.startsWith(a);
            }
          } catch (e) {
            console.error(
              "Error evaluating scan operation, falling back to equality:",
              e,
            );
            isMatch = String(cleanedCode || "") === String(expectedValue || "");
          }

          const scannerInfo = document.getElementById("scan-by").value;
          console.log("Match result:", isMatch);

          // Create scan log entry
          // Build log entry with all field values
          const logEntry = {
            timestamp: new Date(),
            scannedCode: cleanedCode,
            scannerInfo: scannerInfo,
            matchStatus: isMatch ? "MATCHED" : "NOT MATCHED",
          };
          // Add all field values to log - prefer master.xlsx values (currentSelectedRow)
          settings.fields.forEach((field) => {
            let val = "";
            try {
              if (currentSelectedRow) {
                val = getValueFromRow(currentSelectedRow, field.id) || "";
              }
              if (!val) {
                const input = document.getElementById(field.id);
                val = input ? input.value : "";
              }
            } catch (e) {
              val = "";
            }
            logEntry[field.label] = val;
          });
          scanLogs.unshift(logEntry); // Add to beginning of array

          // Save to Excel in real-time
          if (isMatch) {
            // Try to clear failure box for current successful scan (idempotent)
            try {
              tryClearFailureBoxForCurrentScan();
            } catch (e) {}
            // Determine whether this successful scan corresponds to the last shown failure
            try {
              const last = window._lastFailureRecord || null;
              let matchedRowIdx = null;
              let matchedPrimaryVal = null;
              try {
                // If a currentSelectedRow is present, try to resolve its index in masterRawRows
                if (currentSelectedRow) {
                  if (Array.isArray(currentSelectedRow)) {
                    matchedRowIdx =
                      (Array.isArray(masterRawRows) &&
                        masterRawRows.findIndex(
                          (r) => r === currentSelectedRow,
                        )) ||
                      null;
                  } else {
                    // object: try by primary value
                    const pid =
                      (settings &&
                        settings.primaryFields &&
                        settings.primaryFields[0]) ||
                      (settings &&
                        settings.fields &&
                        settings.fields[0] &&
                        settings.fields[0].id) ||
                      null;
                    if (pid) {
                      matchedPrimaryVal =
                        getValueFromRow(currentSelectedRow, pid) || "";
                      if (Array.isArray(masterRawRows)) {
                        matchedRowIdx = masterRawRows.findIndex((r) => {
                          try {
                            return (
                              (typeof getValueFromRow === "function"
                                ? getValueFromRow(r, pid)
                                : "") === matchedPrimaryVal
                            );
                          } catch (e) {
                            return false;
                          }
                        });
                        if (matchedRowIdx === -1) matchedRowIdx = null;
                      }
                    }
                  }
                }
              } catch (e) {}

              const lastMatches = (function () {
                try {
                  if (!last) return false;
                  if (
                    typeof last.excelRowIndex === "number" &&
                    last.excelRowIndex >= 0 &&
                    typeof matchedRowIdx === "number"
                  ) {
                    return last.excelRowIndex === matchedRowIdx;
                  }
                  if (last.primaryValue && matchedPrimaryVal) {
                    return (
                      String(last.primaryValue) === String(matchedPrimaryVal)
                    );
                  }
                  return false;
                } catch (e) {
                  return false;
                }
              })();

              if (lastMatches) {
                try {
                  tryClearFailureBoxForCurrentScan();
                } catch (e) {}
              }
            } catch (e) {}

            console.log("Successful scan - saving to Excel in real-time");
            saveScanLogRealtime(logEntry);
          } else {
            console.log("Failed scan - saving error log to separate file");
            saveErrorScanLogRealtime(logEntry);
          }

          // Update UI with scanned data
          const scanDataValue = document.getElementById("scan-data-value");
          scanDataValue.textContent = cleanedCode;

          if (isMatch) {
            // Handle successful scan
            document.getElementById("scan-status-value").textContent = "OK";
            document.getElementById("scan-status-value").classList.add("ok");
            document.getElementById("part-code-status-value").textContent =
              "DATA MATCHED";
            document
              .getElementById("part-code-status-value")
              .classList.add("ok");
            document.getElementById("pass-status").textContent = "PASS";
            document.getElementById("pass-status").classList.remove("failed");
            document.getElementById("pass-status").classList.add("pass-box");

            // Change back to READY after 1000ms
            setTimeout(() => {
              if (
                window.scanManager &&
                typeof window.scanManager._showReadyState === "function"
              ) {
                window.scanManager._showReadyState();
                try {
                  tryClearFailureBoxForCurrentScan();
                } catch (e) {}
              } else {
                document.getElementById("pass-status").textContent = "READY";
                document
                  .getElementById("pass-status")
                  .classList.remove("pass-box");
                // Clear verification status fields when READY is shown
                document.getElementById("scan-data-value").textContent = "";
                document
                  .getElementById("scan-data-value")
                  .classList.remove("scanned-success");
                document.getElementById("scan-status-value").textContent = "";
                document
                  .getElementById("scan-status-value")
                  .classList.remove("ok");
                document.getElementById("part-code-status-value").textContent =
                  "";
                document
                  .getElementById("part-code-status-value")
                  .classList.remove("ok");
                try {
                  if (typeof window.hideFailureRecordBox === "function")
                    window.hideFailureRecordBox();
                } catch (e) {}
              }
            }, 1000);

            // Highlight the scanned data in green
            scanDataValue.classList.add("scanned-success");

            // Update scan quantity only for successful scans
            const scanQty = document.getElementById("scan-qty");
            scanQty.value = String(Number(scanQty.value) + 1).padStart(5, "0");
          } else {
            // Handle failed scan
            document.getElementById("scan-status-value").textContent = "NOT OK";
            document.getElementById("scan-status-value").classList.remove("ok");
            document.getElementById("part-code-status-value").textContent =
              "NO MATCH";
            document
              .getElementById("part-code-status-value")
              .classList.remove("ok");
            document.getElementById("pass-status").textContent = "FAILED";
            document.getElementById("pass-status").classList.remove("pass-box");
            document.getElementById("pass-status").classList.add("failed");
            document.getElementById("btn-scan-data").classList.add("failed");

            // Play error sound on loop until blink finishes
            const errorSound = document.getElementById("error-sound");
            errorSound.loop = true;
            errorSound.play();
            setTimeout(() => {
              errorSound.pause();
              errorSound.currentTime = 0;
            }, 6000); // Stop after 6 seconds

            // Shake the PIN verification modal
            const pinModal = document.getElementById("pin-modal");
            pinModal.classList.add("shake");
            setTimeout(() => pinModal.classList.remove("shake"), 500);

            // Show red blink overlay
            const blinkOverlay = document.getElementById("blink-overlay");
            blinkOverlay.style.display = "block";
            setTimeout(() => (blinkOverlay.style.display = "none"), 6000); // 2s * 3 = 6s

            // Show PIN verification
            showPinVerification().then((isVerified) => {
              if (isVerified) {
                // Preserve the failed UI so operator can retry the same field.
                // Keep scan-data and status visible, focus the primary input,
                // and ensure the failed field remains selected for re-scan.
                try {
                  const primaryId =
                    (settings.primaryFields && settings.primaryFields[0]) ||
                    (settings.fields &&
                      settings.fields[0] &&
                      settings.fields[0].id) ||
                    null;
                  if (primaryId) {
                    const fld = document.getElementById(primaryId);
                    if (fld) {
                      fld.classList.remove("scan-pending", "scan-passed");
                      fld.classList.add("scan-failed");
                      try {
                        try {
                          window.safeFocus(fld);
                        } catch (e) {}
                      } catch (e) {}
                    }
                  }
                  // Keep pass-status as FAILED until the operator rescans and it passes
                  const passEl = document.getElementById("pass-status");
                  if (passEl) passEl.textContent = "FAILED";
                  // Do not clear scan-data-value or other status fields here
                } catch (e) {
                  console.warn("post-pin: failed to preserve failed UI", e);
                }
              }
            });

            // Show notification for failed scan
            showNotification(
              "Scan does not match the part code. Please verify with PIN to continue.",
              "error",
            );
          }

          // Always update timestamp
          updateTimestamp();

          console.log("Scan processing completed successfully");
        } catch (error) {
          console.error("Error handling scan:", error);
          showNotification("Error processing scan. Please try again.", "error");
        } finally {
          // Ensure UI is ready for next scan after a delay
          setTimeout(() => {
            // Don't clear scan data, just remove success highlight
            document
              .getElementById("scan-data-value")
              .classList.remove("scanned-success");

            // For failed scans, we don't reset the status here anymore
            // The status will be cleared only after successful PIN verification
          }, 200); // Remove success highlight after 0.2 seconds
        }
      }

      // Update timestamp
      function updateTimestamp() {
        const now = new Date();
        document.getElementById("date").value = now.toLocaleDateString("en-GB");
        document.getElementById("time").value = now.toLocaleTimeString("en-GB");
      }

      // Scanner input handling with improved logic
      let scanBuffer = "";
      let scanTimeout;
      let isScanning = false;
      // Suppress verbose keydown logs by default; set to false to re-enable
      window.SUPPRESS_SCANNER_KEYLOGS = true;

      // Listen for keydown events to capture scanner input
      document.addEventListener("keydown", function (e) {
        const targetTag =
          e.target && e.target.tagName ? e.target.tagName : "UNKNOWN";
        const targetId = e.target && e.target.id ? e.target.id : "";
        const targetReadOnly = !!(e.target && e.target.readOnly);
        const suppress = !!window.SUPPRESS_SCANNER_KEYLOGS;
        if (!suppress) {
          console.log(
            "Key detected:",
            e.key,
            "Code:",
            e.code,
            "Target:",
            targetTag,
            targetId,
            "readOnly:",
            targetReadOnly,
          );
        }

        // If focused element is an INPUT/TEXTAREA and editable, ignore to allow manual typing
        if (
          (targetTag === "INPUT" || targetTag === "TEXTAREA") &&
          !targetReadOnly
        ) {
          if (!suppress)
            console.log("Ignoring key - focus is on editable input element");
          return;
        }

        try {
          // Handle Enter key - this signals end of scan
          if (e.key === "Enter" || e.code === "Enter") {
            if (!suppress)
              console.log(
                "Enter key detected - processing scan buffer:",
                scanBuffer,
                "focused:",
                targetTag,
                targetId,
                "readOnly:",
                targetReadOnly,
              );
            e.preventDefault();

            // Clear any existing timeout
            if (scanTimeout) {
              clearTimeout(scanTimeout);
              scanTimeout = null;
            }

            // Process the buffer if it has content
            if (scanBuffer.length > 0) {
              const scannedCode = scanBuffer;
              console.log("Processing scanned code:", scannedCode);
              scanBuffer = ""; // Clear buffer
              isScanning = false;

              // Process the scan
              try {
                handleScan(scannedCode);
              } catch (error) {
                console.error("Error in handleScan:", error);
                showNotification(
                  "Error processing scan. Please try again.",
                  "error",
                );
              }
            } else {
              console.log("Buffer is empty, ignoring Enter key");
            }
            return;
          }

          // Ignore special keys that aren't characters
          if (e.key.length > 1 && e.key !== "Enter") {
            if (!suppress) console.log("Ignoring special key:", e.key);
            return;
          }

          // Start scanning mode
          if (!isScanning) {
            isScanning = true;
            scanBuffer = "";
            if (!suppress)
              console.log("Started scanning mode (scanner capture)");
          }

          // Prevent default so input elements (readOnly) don't receive characters
          try {
            e.preventDefault();
          } catch (e_) {}

          // Add character to buffer
          scanBuffer += e.key;
          // Detailed debug showing buffer and source element (suppressed by default)
          if (!suppress)
            console.log(
              "Buffer updated:",
              scanBuffer,
              "from target:",
              targetTag,
              targetId,
            );

          // Clear existing timeout
          if (scanTimeout) {
            clearTimeout(scanTimeout);
          }

          // Set timeout to auto-process if Enter is not received (fallback)
          scanTimeout = setTimeout(() => {
            if (!suppress)
              console.log(
                "Timeout reached - auto-processing buffer:",
                scanBuffer,
                "from target:",
                targetTag,
                targetId,
              );
            if (scanBuffer.length > 0) {
              const scannedCode = scanBuffer;
              scanBuffer = "";
              isScanning = false;

              try {
                handleScan(scannedCode);
              } catch (error) {
                console.error("Error in handleScan (timeout):", error);
                showNotification(
                  "Error processing scan. Please try again.",
                  "error",
                );
              }
            }
            scanTimeout = null;
          }, 100); // 100ms timeout for scanner input completion
        } catch (error) {
          console.error("Error in keydown handler:", error);
          scanBuffer = "";
          isScanning = false;
          if (scanTimeout) {
            clearTimeout(scanTimeout);
            scanTimeout = null;
          }
        }
      });

      // Debug: confirm listener attachment
      try {
        console.info("Scanner keydown listener attached");
        window.scannerKeydownAttached = true;
      } catch (e) {
        // ignore in non-browser test harness
      }

      // Helper function to show notifications
      function showNotification(message, type = "info") {
        const notification = document.createElement("div");
        notification.style.position = "fixed";
        notification.style.top = "20px";
        notification.style.left = "50%";
        notification.style.transform = "translateX(-50%)";
        notification.style.backgroundColor =
          type === "error" ? "#ff3b30" : "#4CAF50";
        notification.style.color = "white";
        notification.style.padding = "10px 20px";
        notification.style.borderRadius = "5px";
        notification.style.zIndex = "9999";
        notification.style.boxShadow = "0 2px 8px rgba(0,0,0,0.3)";
        notification.textContent = message;
        document.body.appendChild(notification);

        setTimeout(() => {
          if (document.body.contains(notification)) {
            try {
              if (notification && notification.remove) notification.remove();
              else if (notification && notification.parentNode)
                notification.parentNode.removeChild(notification);
            } catch (e) {}
          }
        }, 2000);
      }

      // Handle logo image loading
      function initializeLogo() {
        const logoImg = document.getElementById("logo-img");
        const logoText = document.getElementById("logo-text");

        logoImg.addEventListener("load", function () {
          // Show image and hide text when image loads successfully
          logoImg.style.display = "block";
          logoText.style.display = "none";
        });

        logoImg.addEventListener("error", function () {
          // Hide image and show text if image fails to load
          logoImg.style.display = "none";
          logoText.style.display = "block";
        });
      }

      // Function to show PIN verification modal
      async function showPinVerification() {
        return new Promise((resolve) => {
          const pinModal = document.getElementById("pin-modal");
          const pinInput = document.getElementById("pin-input");
          const pinError = document.getElementById("pin-error");
          const verifyBtn = document.getElementById("verify-pin-btn");

          // Remember whether parts modal was visible so we only restore it when appropriate
          const partsModal = document.getElementById("parts-modal");
          const partsWasVisible =
            partsModal && partsModal.style.display !== "none";

          // Clear previous state but keep error states
          pinInput.value = "";
          pinError.textContent = "";

          // Hide parts modal while PIN modal is focused (if it exists)
          try {
            if (partsModal) partsModal.style.display = "none";
          } catch (e) {}

          // Show the modal
          pinModal.style.zIndex = "9999"; // Ensure modal is on top
          setTimeout(() => {
            pinModal.style.display = "block";
          }, 100);

          // Handle Enter key in PIN input
          const handleKeyPress = (e) => {
            if (e.key === "Enter") {
              verifyPin();
            }
          };

          // Verify PIN function
          const verifyPin = async () => {
            const pin = pinInput.value.trim();
            try {
              // Read the PIN from the file
              const response = await fetch("mod-base.txt");
              const savedPin = (await response.text()).trim();

              if (pin === atob(savedPin)) {
                // On successful verification, clear any failure UI
                try {
                  clearFailureHighlights();
                } catch (e) {}

                pinModal.style.display = "none";
                pinInput.removeEventListener("keypress", handleKeyPress);
                verifyBtn.removeEventListener("click", verifyPin);
                resolve(true);
              } else {
                pinError.textContent = "Invalid PIN. Please try again.";
                pinInput.value = "";
                try {
                  window.safeFocus(pinInput);
                } catch (e) {}
                // Restore parts modal only if it was visible before opening PIN modal
                try {
                  if (partsWasVisible && partsModal)
                    partsModal.style.display = "block";
                } catch (e) {
                  console.warn(
                    "Could not re-open parts modal after PIN failure",
                    e,
                  );
                }
              }
            } catch (error) {
              console.error("Error verifying PIN:", error);
              pinError.textContent = "Error verifying PIN. Please try again.";
            }
          };

          // Set up event listeners
          pinInput.addEventListener("keypress", handleKeyPress);
          verifyBtn.addEventListener("click", verifyPin);
        });
      }

      // Clear any failure highlights from scan inputs and global UI
      function clearFailureHighlights() {
        try {
          const flds = (window.settings && window.settings.fields) || [];
          flds.forEach((f) => {
            try {
              const el = document.getElementById(f.id);
              if (!el) return;
              el.classList.remove(
                "scan-failed",
                "scan-pending",
                "scan-active",
                "scan-passed",
                "failed",
              );
              el.style.background = "";
              el.style.color = "";
              el.style.border = "";
              el.style.borderColor = "";
              el.style.boxShadow = "";
              el.style.outline = "";
            } catch (e) {}
          });

          // Generic cleanup for any residual markers
          document
            .querySelectorAll(
              ".scan-failed, .failed, .reg-highlight, .regex-highlight",
            )
            .forEach((node) => {
              try {
                node.classList.remove("scan-failed", "failed");
                node.style.background = "";
                node.style.color = "";
                node.style.border = "";
                node.style.boxShadow = "";
                node.style.outline = "";
                // If it's a highlight span, replace with plain text
                if (
                  node.classList.contains("reg-highlight") ||
                  node.classList.contains("regex-highlight")
                ) {
                  const txt = node.textContent || "";
                  const parent = node.parentNode;
                  if (parent)
                    parent.replaceChild(document.createTextNode(txt), node);
                }
              } catch (e) {}
            });

          try {
            const passEl = document.getElementById("pass-status");
            if (passEl) {
              passEl.classList.remove("failed");
              passEl.style.background = "";
              passEl.style.color = "";
            }
          } catch (e) {}
          try {
            const scanBtn = document.getElementById("btn-scan-data");
            if (scanBtn) {
              scanBtn.classList.remove("failed");
              scanBtn.style.background = "";
              scanBtn.style.color = "";
            }
          } catch (e) {}
          try {
            const blink = document.getElementById("blink-overlay");
            if (blink) blink.style.display = "none";
          } catch (e) {}
        } catch (e) {}
      }

      // Perform cleanup after a master item has been selected.
      // This is intentionally scoped to master-selection flows and differs
      // from generic failure clearing: it will also remove `required`
      // markers for inputs that are now populated.
      function normalizeAfterMasterSelect() {
        try {
          // Clear scan-related classes and inline styles from configured inputs
          (settings.fields || []).forEach((f) => {
            try {
              const el = document.getElementById(f.id);
              if (!el) return;
              el.classList.remove(
                "scan-active",
                "scan-pending",
                "scan-passed",
                "scan-failed",
                "failed",
                "required",
              );
              // If the input has a value, ensure `required` is removed
              if (String(el.value || "").trim())
                el.classList.remove("required");
              el.style.background = "";
              el.style.color = "";
              el.style.border = "";
              el.style.boxShadow = "";
              el.style.outline = "";
            } catch (e) {}
          });

          // Remove any DOM highlight markers inserted by regex-highlighting routines
          try {
            document
              .querySelectorAll(".reg-highlight, .regex-highlight")
              .forEach((node) => {
                try {
                  const txt = node.textContent || "";
                  const parent = node.parentNode;
                  if (parent)
                    parent.replaceChild(document.createTextNode(txt), node);
                } catch (e) {}
              });
          } catch (e) {}

          // Clear global failed indicators (pass-status, scan buttons)
          try {
            const passEl = document.getElementById("pass-status");
            if (passEl) {
              passEl.classList.remove("failed");
              passEl.style.background = "";
              passEl.style.color = "";
            }
          } catch (e) {}
          try {
            const scanBtn = document.getElementById("btn-scan-data");
            if (scanBtn) {
              scanBtn.classList.remove("failed");
              scanBtn.style.background = "";
              scanBtn.style.color = "";
            }
          } catch (e) {}

          try {
            const blink = document.getElementById("blink-overlay");
            if (blink) blink.style.display = "none";
          } catch (e) {}

          // If scanManager is present, ask it to show ready state
          try {
            if (
              window.scanManager &&
              typeof window.scanManager._showReadyState === "function"
            ) {
              window.scanManager._showReadyState();
            }
          } catch (e) {}
        } catch (e) {}
      }

      // Show scanner name modal and return the entered name (or null on cancel)
      async function showScannerNameModal() {
        console.log("showScannerNameModal: opening modal");
        return new Promise((resolve) => {
          const modal = document.getElementById("scanner-modal");
          const input = document.getElementById("scanner-input");
          const error = document.getElementById("scanner-error");
          const saveBtn = document.getElementById("save-scanner-btn");
          const cancelBtn = document.getElementById("cancel-scanner-btn");

          // Reset state
          input.value = document.getElementById("scan-by")?.value || "";
          console.log(
            "showScannerNameModal: prefill current name =",
            input.value,
          );
          error.textContent = "";
          modal.style.display = "block";
          input.focus();

          const close = (result = null) => {
            console.log(
              "showScannerNameModal: closing modal with result =",
              result,
            );
            modal.style.display = "none";
            input.removeEventListener("keypress", onKey);
            saveBtn.removeEventListener("click", onSave);
            cancelBtn.removeEventListener("click", onCancel);
            modal.removeEventListener("click", onOutsideClick);
            resolve(result);
          };

          const onSave = () => {
            const name = input.value.trim();
            console.log("showScannerNameModal: save attempt with name =", name);
            if (!name) {
              error.textContent = "Name cannot be empty.";
              input.focus();
              return;
            }
            close(name);
          };

          const onCancel = () => {
            console.log("showScannerNameModal: canceled");
            close(null);
          };

          const onKey = (e) => {
            if (e.key === "Enter") onSave();
            if (e.key === "Escape") onCancel();
          };

          const onOutsideClick = (e) => {
            if (e.target === modal) onCancel();
          };

          input.addEventListener("keypress", onKey);
          saveBtn.addEventListener("click", onSave);
          cancelBtn.addEventListener("click", onCancel);
          modal.addEventListener("click", onOutsideClick);
        });
      }

      // Function to get all used licenses
      function getAllUsedLicenses() {
        try {
          if (!fs.existsSync("used-license.txt")) {
            fs.writeFileSync("used-license.txt", "[]", "utf8");
            return [];
          }

          let content = fs.readFileSync("used-license.txt", "utf8").trim();

          // Handle empty file
          if (!content) {
            fs.writeFileSync("used-license.txt", "[]", "utf8");
            return [];
          }

          // Fix common JSON formatting issues
          content = content.trim();

          // Ensure the content is a valid JSON array
          if (!content.startsWith("[")) {
            content = "[" + content;
          }
          if (!content.endsWith("]")) {
            content = content + "]";
          }

          // Remove trailing commas before closing bracket/brace
          content = content.replaceAll(/,\s*([}\]])/g, "$1");

          try {
            const parsed = JSON.parse(content);
            return Array.isArray(parsed) ? parsed : [];
          } catch (e) {
            console.warn("Failed to parse used licenses, resetting file", e);
            try {
              fs.writeFileSync("used-license.txt", "[]", "utf8");
            } catch (error_) {
              console.error("Failed to write reset used-license.txt:", error_);
            }
            return [];
          }
        } catch (error) {
          console.error("Error reading used licenses:", error);
          alert("Error reading used licenses. Please check file permissions.");
          try {
            fs.writeFileSync("used-license.txt", "[]", "utf8");
          } catch (e) {
            console.error("Failed to reset used-license.txt:", e);
            alert("Failed to reset used-license.txt.");
          }
          return [];
        }
      }

      // Function to check if license key has been used before
      function isLicenseUsed(licenseKey) {
        if (!licenseKey) return true; // Treat empty key as used

        const usedLicenses = getAllUsedLicenses();

        // Check both the original key and its base64 version
        if (usedLicenses.includes(licenseKey)) {
          return true;
        }

        // If it's a date string, check its base64 version too
        if (/^\d{2}-\d{2}-\d{4}$/.test(licenseKey)) {
          try {
            const base64Key = btoa(licenseKey);
            return usedLicenses.includes(base64Key);
          } catch (e) {
            console.error("Error encoding license key:", e);
          }
        }

        return false;
      }

      // Function to mark a license key as used (only adds to used-license.txt, never modifies license.txt)
      function markLicenseAsUsed(licenseKey) {
        if (!licenseKey) return;

        try {
          // Always encode the key to base64 for storage
          let keyToStore = /^\d{2}-\d{2}-\d{4}$/.test(licenseKey)
            ? btoa(licenseKey)
            : licenseKey;

          const usedLicenses = getAllUsedLicenses();
          if (!usedLicenses.includes(keyToStore)) {
            usedLicenses.push(keyToStore);
            fs.writeFileSync(
              "used-license.txt",
              JSON.stringify(usedLicenses, null, 2),
              "utf8",
            );
            console.log("License key added to used licenses");
          }
        } catch (error) {
          console.error("Error saving used license:", error);
        }
      }

      // Function to set the current license (only updates license.txt with date string)
      function setCurrentLicense(licenseDateStr) {
        if (!/^\d{2}-\d{2}-\d{4}$/.test(licenseDateStr)) {
          console.error("Invalid date format for license");
          return false;
        }

        try {
          fs.writeFileSync("license.txt", licenseDateStr, "utf8");
          console.log("Current license date set to:", licenseDateStr);
          return true;
        } catch (error) {
          console.error("Error setting current license:", error);
          return false;
        }
      }

      // Function to validate license format
      function isValidLicenseFormat(licenseKey) {
        if (!licenseKey) return false;
        const vowels = "aeiouAEIOU";
        return (
          licenseKey.length > 0 &&
          vowels.includes(licenseKey[0]) &&
          vowels.includes(licenseKey[licenseKey.length - 1])
        );
      }

      // Function to check if a string is valid base64
      function isBase64(str) {
        try {
          return btoa(atob(str)) === str;
        } catch (err) {
          console.error("Error validating base64 string:", err);
          alert("Error validating base64 string.");
          return false;
        }
      }

      // Function to parse license date from either base64 or plain text
      function parseLicenseContent(licenseContent) {
        try {
          // First try to decode as base64
          try {
            const decoded = atob(licenseContent);
            // If it's in the expected date format (DD-MM-YYYY)
            if (/^\d{2}-\d{2}-\d{4}$/.test(decoded)) {
              return decoded;
            }
          } catch (e) {
            // Decoding failed or input wasn't base64 â€” log and continue to plain-text check
            console.warn("Not a valid base64 string or decode failed:", e);
          }

          // If not base64 or not in expected format, try as plain text
          if (/^\d{2}-\d{2}-\d{4}$/.test(licenseContent)) {
            return licenseContent;
          }

          // If we get here, the format is invalid
          throw new Error(
            "Invalid license format. Expected DD-MM-YYYY or base64 encoded date.",
          );
        } catch (error) {
          console.error("Error parsing license:", error);
          alert("Error parsing license. Please check the format.");
          throw error;
        }
      }

      // License check function â€” returns Promise<boolean>
      async function checkLicense() {
        // Check if this is a license validation attempt with a new key
        const urlParams = new URLSearchParams(globalThis.location.search);
        const newLicenseKey = urlParams.get("license");

        // Function to show license modal and get new license
        const showLicenseModal = (message = "") => {
          return new Promise((resolve) => {
            const modal = document.getElementById("license-modal");
            const input = document.getElementById("license-key-input");
            const error = document.getElementById("license-error");
            const btn = document.getElementById("verify-license-btn");

            if (!modal || !input || !error || !btn) {
              console.error("License modal elements not found");
              resolve(false);
              return;
            }

            // Clear any previous messages
            error.textContent = message || "";
            input.value = "";
            // ensure overlay visible and modal focused
            try {
              document.getElementById("license-invalid-overlay").style.display =
                "none";
            } catch (e) {}
            // use flex so modal content centers as per CSS
            modal.style.display = "flex";
            try {
              window.safeFocus(input);
            } catch (e) {}

            const verify = () => {
              const key = input.value.trim();

              if (!isValidLicenseFormat(key)) {
                error.textContent =
                  "Invalid license key. Please check your key and try again.";
                input.value = "";
                try {
                  window.safeFocus(input);
                } catch (e) {}
                return;
              }

              if (isLicenseUsed(key)) {
                error.textContent =
                  "This license key has already been used. Please enter a different key.";
                input.value = "";
                input.focus();
                return;
              }

              // If we get here, the license is valid and unused
              // Mark as used and grant a 7-day extension by writing expiry date
              markLicenseAsUsed(key);
              try {
                const now = new Date();
                const expire = new Date(now);
                expire.setDate(expire.getDate() + 7);
                const dd = String(expire.getDate()).padStart(2, "0");
                const mm = String(expire.getMonth() + 1).padStart(2, "0");
                const yyyy = expire.getFullYear();
                const expiryStr = `${dd}-${mm}-${yyyy}`;
                fs.writeFileSync("license.txt", btoa(expiryStr), "utf8");
                console.log(
                  "License accepted via modal. Temporary expiry set to:",
                  expiryStr,
                );
              } catch (e) {
                console.error("Failed to write license expiry from modal:", e);
              }
              modal.style.display = "none";
              resolve(true);
            };

            // Remove any existing event listeners to prevent duplicates
            const newBtn = btn.cloneNode(true);
            btn.parentNode.replaceChild(newBtn, btn);
            newBtn.addEventListener("click", verify);

            // Handle Enter key press
            input.onkeypress = (e) => {
              if (e.key === "Enter") {
                verify();
              }
            };
          });

          // Ensure required class reflects populated values: remove red border for populated inputs
          try {
            settings.fields.forEach((field) => {
              const input = document.getElementById(field.id);
              if (!input) return;
              const val = String(input.value || "").trim();
              if (val) {
                input.classList.remove("required");
              }
            });
          } catch (e) {
            console.warn(
              "rebuildInputUI: failed to reconcile required classes",
              e,
            );
          }
        };

        // If we have a new license key from URL, validate it and write expiry
        if (newLicenseKey) {
          if (isLicenseUsed(newLicenseKey)) {
            console.log("This license key has already been used");
            return await showLicenseModal(
              "This license key has already been used. Please enter a different key.",
            );
          }
          // If not used, mark it as used and grant a 7-day extension by writing expiry date
          markLicenseAsUsed(newLicenseKey);
          try {
            const now = new Date();
            const expire = new Date(now);
            expire.setDate(expire.getDate() + 7); // 7-day extension
            const dd = String(expire.getDate()).padStart(2, "0");
            const mm = String(expire.getMonth() + 1).padStart(2, "0");
            const yyyy = expire.getFullYear();
            const expiryStr = `${dd}-${mm}-${yyyy}`;
            // Store as base64 encoded date so parseLicenseContent will decode it
            fs.writeFileSync("license.txt", btoa(expiryStr), "utf8");
            console.log(
              "New license accepted. Temporary expiry set to:",
              expiryStr,
            );
            // proceed with validated license
            try {
              document.getElementById("license-invalid-overlay").style.display =
                "none";
            } catch (e) {}
            try {
              document.getElementById("license-modal").style.display = "none";
            } catch (e) {}
            try {
              clearFailureHighlights();
            } catch (e) {}
            return true;
          } catch (e) {
            console.error("Failed to write new license expiry:", e);
            // Fallback: write the raw key if date write fails
            try {
              fs.writeFileSync("license.txt", newLicenseKey, "utf8");
              return true;
            } catch (err) {
              console.error("Fallback write also failed:", err);
              return await showLicenseModal(
                "Failed to accept license. Please enter a different key.",
              );
            }
          }
        }

        try {
          // Check if we have a valid license file
          if (!fs.existsSync("license.txt")) {
            return await showLicenseModal(
              "No license found. Please enter a valid license key.",
            );
          }

          const licenseContent = fs.readFileSync("license.txt", "utf8").trim();

          if (!licenseContent) {
            return await showLicenseModal(
              "License file is empty. Please enter a valid license key.",
            );
          }

          // Parse the license content (handles both base64 and plain text)
          let licenseDateStr;
          try {
            licenseDateStr = parseLicenseContent(licenseContent);
          } catch (e) {
            return await showLicenseModal(
              "Invalid license format. Please enter a valid license key.",
            );
          }

          // Parse the date parts for validation
          const [day, month, year] = licenseDateStr.split("-");
          const licenseDate = new Date(`${year}-${month}-${day}`);
          const currentDate = new Date();
          currentDate.setHours(0, 0, 0, 0);
          licenseDate.setHours(0, 0, 0, 0);

          // Log license validity information
          console.log(`License valid until: ${day}-${month}-${year}`);

          if (currentDate > licenseDate) {
            console.log(
              `License expired. License was valid until: ${day}-${month}-${year}`,
            );
            return await showLicenseModal(
              `License expired on ${day}-${month}-${year}. Please enter a new license key.`,
            );
          }

          // License is valid â€” ensure modals/overlays are hidden and proceed
          try {
            document.getElementById("license-invalid-overlay").style.display =
              "none";
          } catch (e) {}
          try {
            document.getElementById("license-modal").style.display = "none";
          } catch (e) {}
          console.log("License valid");
          return true;
        } catch (error) {
          console.error("License check failed:", error);
          return await showLicenseModal(
            "License check failed. Please enter a valid license key.",
          );
        }
      }

      // Initialize
      document.addEventListener("DOMContentLoaded", async function () {
        const licenseValid = await checkLicense();
        if (!licenseValid) {
          document.getElementById("license-invalid-overlay").style.display =
            "block";
          return; // Stop initialization
        }
        // Initialize logo
        initializeLogo();

        // Make 'Scan By' clickable to set scanner name (with part selection check)
        const scanByInput = document.getElementById("scan-by");
        if (scanByInput) {
          scanByInput.addEventListener("click", async (event) => {
            const allowed = await checkPartSelectedBeforeAction();
            if (!allowed) {
              event.preventDefault();
              return;
            }
            console.log("Scan By field clicked");
            const name = await showScannerNameModal();
            console.log("Scanner name modal resolved with:", name);
            if (name && name.trim()) {
              const trimmed = name.trim();
              scanByInput.value = trimmed;
              // Remove the 'required' red highlight now that the user provided a name
              try {
                scanByInput.classList.remove("required");
              } catch (e) {}
              showNotification(`Scan By set to ${trimmed}`, "info");
            }
          });
        } else {
          console.warn("scan-by input not found during init");
        }

        // Modal functionality
        const modal = document.getElementById("parts-modal");
        const closeBtn = modal.querySelector(".close-modal");
        const searchBox = modal.querySelector(".search-box");
        const partsList = modal.querySelector(".parts-list");
        const refreshMasterBtn = modal.querySelector("#refresh-master-btn");

        function showPartsModal() {
          if (!Array.isArray(masterRawRows) || masterRawRows.length === 0) {
            alert(
              "No master data available. Please check the master.xlsx file.",
            );
            return;
          }
          modal.style.display = "block";
          modal.style.zIndex = "1000";
          try {
            window.safeFocus(searchBox);
            // Call grouping opener safely (avoid ReferenceError if not in scope)
            if (typeof maybeOpenGroupedPartsModal === "function") {
              maybeOpenGroupedPartsModal();
            } else if (
              typeof window.maybeOpenGroupedPartsModal === "function"
            ) {
              window.maybeOpenGroupedPartsModal();
            } else {
              renderPartsList(masterRawRows);
            }
          } catch (e) {
            console.warn("Grouping failed, falling back to flat parts list", e);
            renderPartsList(masterRawRows);
          }
        }

        // Wire refresh button to reload master.xlsx and re-render list
        if (refreshMasterBtn) {
          try {
            refreshMasterBtn.addEventListener("click", async (e) => {
              try {
                refreshMasterBtn.disabled = true;
                refreshMasterBtn.textContent = "Refreshing...";
                // Force reload master data from disk and overwrite in-memory object
                await loadMasterData(true);
                // If grouping active, try to re-open grouping view, otherwise render full list
                if (_groupState && _groupState.enabled) {
                  try {
                    renderGroupValues(_groupState.levels ? 0 : 0);
                  } catch (e) {
                    renderPartsList(masterData);
                  }
                } else {
                  renderPartsList(masterData);
                }
                showNotification("Master data refreshed from Excel", "info");
              } catch (err) {
                console.error("Failed to refresh master data:", err);
                showNotification("Failed to refresh master data", "error");
              } finally {
                refreshMasterBtn.disabled = false;
                refreshMasterBtn.textContent = "Refresh";
              }
            });
          } catch (e) {
            console.warn("Failed to wire refreshMasterBtn", e);
          }
        }

        function hidePartsModal() {
          modal.style.display = "none";
          searchBox.value = "";
        }

        function renderPartsList(parts) {
          const safeParts = Array.isArray(parts) ? parts : [];

          // Optional debug snapshot (kept safe; never breaks rendering)
          try {
            window._masterDataDebug = window._masterDataDebug || {};
            window._masterDataDebug.lastRenderedParts = safeParts.map(
              (item) => {
                const idx = masterData.findIndex((m) => m === item);
                const primaryVal = getPrimaryValue(item) || "N/A";
                const displayFields = Array.isArray(settings.displayFields)
                  ? settings.displayFields
                  : settings.displayField
                    ? [settings.displayField]
                    : [];
                const displayVals = (displayFields || []).map((fid) => ({
                  id: fid,
                  val: getValueFromRowStrict(item, fid) || "",
                }));
                return {
                  rowIndex: idx,
                  primaryValue: primaryVal,
                  displayValues: displayVals,
                };
              },
            );
          } catch (e) {
            console.warn("renderPartsList: failed debug snapshot", e);
          }

          if (!partsList) return;
          if (safeParts.length === 0) {
            partsList.innerHTML =
              '<div class="no-results">No matching parts found</div>';
            return;
          }

          partsList.innerHTML = safeParts
            .map((item) => {
              // Determine corresponding index in masterRawRows whenever possible
              let idx = -1;
              const primaryId = getPrimaryFieldId();
              let primaryVal = "N/A";

              if (Array.isArray(item)) {
                idx = masterRawRows.findIndex((r) => r === item);
                primaryVal = getValueFromRow(item, primaryId) || "N/A";
                if (idx === -1 && primaryVal && primaryVal !== "N/A") {
                  idx = masterRawRows.findIndex((r) => {
                    const mv = getValueFromRow(r, primaryId) || "";
                    return (
                      mv && String(mv).trim() === String(primaryVal).trim()
                    );
                  });
                }
              } else {
                // item might be legacy mapped object
                idx = masterData.findIndex((m) => m === item);
                primaryVal = getPrimaryValue(item) || "N/A";
                if (idx === -1 && primaryVal && primaryVal !== "N/A") {
                  idx = masterRawRows.findIndex((r) => {
                    const mv = getValueFromRow(r, primaryId) || "";
                    return (
                      mv && String(mv).trim() === String(primaryVal).trim()
                    );
                  });
                }
              }

              // Use configured display fields. Support new `displayFields` (array)
              // or legacy `displayField` (string). Show first as main text and
              // append additional fields in parentheses.
              let displayContent = "";
              const displayFields = Array.isArray(settings.displayFields)
                ? settings.displayFields
                : settings.displayField
                  ? [settings.displayField]
                  : null;

              if (displayFields && displayFields.length > 0) {
                const mainId = displayFields[0];
                const mainVal = getValueFromRowStrict(item, mainId) || "N/A";
                displayContent = `<span class="part-code" style="font-weight: bold; font-size: 1.1em;">${mainVal}</span>`;

                // Collect appended values from remaining displayFields
                const appended = displayFields
                  .slice(1)
                  .map((fid) => getValueFromRowStrict(item, fid) || "")
                  .filter(Boolean);
                if (appended.length > 0) {
                  // Use higher contrast and larger text for appended/bracketed values
                  displayContent += ` <span class="part-badge">(${appended.join(
                    " | ",
                  )})</span>`;
                } else if (
                  !settings.primaryFields ||
                  !settings.primaryFields.includes(mainId)
                ) {
                  // If no appended fields, show primaryVal in a brighter color if different
                  displayContent += ` <span class="part-badge">(${primaryVal})</span>`;
                }
              } else {
                // Fallback: show first 3 fields
                displayContent = settings.fields
                  .slice(0, 3)
                  .map(
                    (f) =>
                      `<span class="part-code">${
                        getValueFromRow(item, f.id) || "N/A"
                      }</span>`,
                  )
                  .join(" ");
              }

              // Log exact raw expected primary value for debugging
              try {
                console.log(`Master row ${idx}: primary raw = ${primaryVal}`);
              } catch (e) {}

              return `
          <li class="part-item" data-row-index="${idx}" data-primary-value="${primaryVal}">
            <div class="part-info">
              <span class="index-badge">[#${idx}]</span>
              ${displayContent}
            </div>
          </li>`;
            })
            .join("");
        }

        // Grouping runtime state and helpers
        let _groupState = {
          enabled: false,
          levels: [],
          selections: [],
          currentFilteredRows: null,
          searchTerms: [], // Store search term per level for independent search
        };

        function escapeHtml(s) {
          try {
            return String(s)
              .replace(/&/g, "&amp;")
              .replace(/</g, "&lt;")
              .replace(/>/g, "&gt;")
              .replace(/"/g, "&quot;")
              .replace(/'/g, "&#39;");
          } catch (e) {
            return "";
          }
        }

        function computeUniqueValues(rows, headerKey) {
          // Robustly resolve a value for the grouping key using existing helpers,
          // so it works for both raw array rows and object-mapped rows.
          const counts = new Map();
          (rows || []).forEach((r) => {
            let v = "";
            try {
              // Try direct lookup by key
              if (r && Object.prototype.hasOwnProperty.call(r, headerKey)) {
                v = r[headerKey];
              } else {
                // Fall back to using field resolution via a temporary field descriptor
                const tempField = { id: "__grp__", label: "__grp__", header: headerKey, headerCol: headerKey };
                v = getValueFromRow(r, tempField.id);
                if (!v) {
                  // If headerKey is a column letter or name, try strict lookup via synthetic row map
                  // Build a minimal synthetic field array context
                  const desiredNorm = normalizeHeader(headerKey || "");
                  const hi = (headerInfos || []).find(
                    (h) => h.col === headerKey || h.name === headerKey || h.norm === desiredNorm,
                  );
                  if (hi) {
                    if (Array.isArray(r)) {
                      const idx = headerInfos.indexOf(hi);
                      if (idx >= 0 && r[idx] !== undefined && r[idx] !== null) v = r[idx];
                    } else if (r && typeof r === "object") {
                      const tryKeys = [hi.uniqueKey, hi.col, hi.name, hi.norm].filter(Boolean);
                      for (const k of tryKeys) {
                        if (Object.prototype.hasOwnProperty.call(r, k)) {
                          v = r[k];
                          break;
                        }
                      }
                    }
                  }
                }
              }
            } catch (e) {
              v = "";
            }
            const key = String(v !== undefined && v !== null ? v : "").trim();
            counts.set(key, (counts.get(key) || 0) + 1);
          });
          return Array.from(counts.entries())
            .map(([value, count]) => ({ value, count }))
            .sort((a, b) => b.count - a.count || a.value.localeCompare(b.value));
        }

        // Note: group reset button removed; group controls now reuse
        // the main `refresh-master-btn` for refreshing master data.

        function getGroupLevelInfo(levelIndex) {
          const lvl =
            _groupState && _groupState.levels
              ? _groupState.levels[levelIndex]
              : null;
          // Backward compatible: older code stored levels as strings
          if (typeof lvl === "string") {
            return { key: lvl, label: lvl };
          }
          if (lvl && typeof lvl === "object") {
            const key = String(
              lvl.key || lvl.headerCol || lvl.header || "",
            ).trim();
            const label = String(
              lvl.label || lvl.header || lvl.key || "",
            ).trim();
            return { key, label: label || key };
          }
          return { key: "", label: "" };
        }

        function renderGroupValues(levelIndex) {
          const groupControls = document.getElementById("group-controls");
          const breadcrumb = document.getElementById("group-breadcrumb");
          const refreshBtn = document.getElementById("refresh-master-btn");
          const summary = document.getElementById("group-summary");
          const searchBox = document.querySelector(".search-box");

          if (!groupControls || !breadcrumb || !refreshBtn)
            return renderPartsList(masterData);

          groupControls.style.display = "block";

          // start with masterData and apply prior selections
          let rows = masterData.slice();
          for (let i = 0; i < levelIndex; i++) {
            const sel = _groupState.selections[i];
            if (sel && sel.header) {
              rows = rows.filter(
                (r) => String(r[sel.header] || "") === String(sel.value || ""),
              );
            }
          }
          _groupState.currentFilteredRows = rows;

          const lvlInfo = getGroupLevelInfo(levelIndex);
          const headerKey = lvlInfo.key;
          const headerLabel = lvlInfo.label;
          // Apply per-level saved search term to this level's rows before computing uniques
          const savedSearchTerm = _groupState.searchTerms[levelIndex] || "";
          let effectiveRows = rows;
          if (savedSearchTerm) {
            const s = String(savedSearchTerm).toLowerCase();
            try {
              effectiveRows = rows.filter((item) => {
                return (settings.fields || []).some((f) => {
                  try {
                    const v = String(getValueFromRow(item, f.id) || "").toLowerCase();
                    return v.includes(s);
                  } catch (e) {
                    return false;
                  }
                });
              });
            } catch (e) {
              effectiveRows = rows;
            }
          }
          _groupState.currentFilteredRows = effectiveRows;
          const uniques = computeUniqueValues(effectiveRows, headerKey);

          // Update breadcrumb with level indicator
          breadcrumb.textContent =
            _groupState.selections.map((s) => s.value).join(" Â» ") ||
            `Level ${levelIndex + 1}: ${headerLabel}`;

          // Summary text
          try {
            const totalExcel = Array.isArray(masterData)
              ? masterData.length
              : 0;
            const currentPool = Array.isArray(rows) ? rows.length : 0;
            const groupCount = Array.isArray(uniques) ? uniques.length : 0;
            if (summary) {
              summary.innerHTML = `
                <div class="group-summary">
                  <div class="summary-title">Total items found in Master Excel: ${totalExcel}</div>
                  <div>Items in current selection: <b>${currentPool}</b></div>
                  <div>Groups at this level: <b>${groupCount}</b></div>
                  <div class="summary-note">Select an item to navigate. Use Back/Refresh anytime.</div>
                </div>
              `;
            }
          } catch (e) {}

          // Restore search term for this level if it exists
          if (searchBox && searchBox.value !== savedSearchTerm) {
            searchBox.value = savedSearchTerm;
          }

          partsList.innerHTML = uniques
            .map((u) => {
              const pct = rows.length
                ? Math.round((u.count / rows.length) * 100)
                : 0;
              const valueEnc = encodeURIComponent(String(u.value || ""));
              const headerEnc = encodeURIComponent(String(headerKey || ""));
              const titleText = String(u.value || "").trim()
                ? String(u.value)
                : `No ${headerLabel}`;
              return `
              <li class="group-value-item" data-value-enc="${valueEnc}" data-header-enc="${headerEnc}">
                <div class="part-info" style="flex: 1;">
                  <div class="group-card-title">${escapeHtml(titleText)}</div>
                  <div class="group-card-subtitle">Group value for <b>${escapeHtml(
                    headerLabel,
                  )}</b></div>
                </div>
                <div class="group-card-meta">
                  <div class="group-meta-badge">${u.count} items</div>
                  <div class="group-meta-sub" style="font-size:0.95em; opacity:0.9">${pct}% of current</div>
                </div>
              </li>`;
            })
            .join("");

          partsList.querySelectorAll(".group-value-item").forEach((li) => {
            li.addEventListener("click", () => {
              // Save current search term before navigating
              if (searchBox) {
                _groupState.searchTerms[levelIndex] = searchBox.value || "";
              }
              const value = decodeURIComponent(li.dataset.valueEnc || "");
              const header = decodeURIComponent(li.dataset.headerEnc || "");
              _groupState.selections[levelIndex] = {
                levelIndex,
                header,
                value,
              };
              const nextIndex = levelIndex + 1;
              if (nextIndex >= (_groupState.levels || []).length) {
                const filtered = masterData.filter((r) =>
                  _groupState.selections.every(
                    (s) => String(r[s.header] || "") === String(s.value || ""),
                  ),
                );
                renderPartsList(filtered);
              } else {
                renderGroupValues(nextIndex);
              }
            });
          });

          // (handlers wired via ensureGroupNavButtonsWired)
        }

        // Decide whether to open grouped navigation or show the flat list.
        // This is called from showPartsModal().
        function maybeOpenGroupedPartsModal() {
          const groupControls = document.getElementById("group-controls");

          // Build grouping levels from persisted settings.groupingFields.
          const groupingFields = Array.isArray(settings.groupingFields)
            ? settings.groupingFields
            : [];
          const levels = groupingFields
            .map((f) => {
              if (!f) return null;
              const key = String(f.headerCol || f.header || "").trim();
              const label = String(f.header || f.label || key || "").trim();
              if (!key) return null;
              return { key, label: label || key };
            })
            .filter(Boolean);

          // Reset state on open so Levelâ€‘1 always starts fresh.
          _groupState.selections = [];
          _groupState.currentFilteredRows = null;

          if (!levels.length) {
            _groupState.enabled = false;
            _groupState.levels = [];
            if (groupControls) groupControls.style.display = "none";
            return renderPartsList(masterData);
          }

          _groupState.enabled = true;
          _groupState.levels = levels;
          return renderGroupValues(0);
        }

        // Expose for safety if other scopes call it
        try {
          window.maybeOpenGroupedPartsModal = maybeOpenGroupedPartsModal;
        } catch (e) {}

        function filterParts(searchTerm) {
          const base =
            _groupState &&
            _groupState.enabled &&
            _groupState.currentFilteredRows
              ? _groupState.currentFilteredRows
              : masterData;
          const filtered = base.filter((item) => {
            const search = String(searchTerm || "").toLowerCase();
            if (!search) return true;
            return settings.fields.some((f) => {
              try {
                const v = String(
                  getValueFromRow(item, f.id) || "",
                ).toLowerCase();
                return v.includes(search);
              } catch (e) {
                return false;
              }
            });
          });
          // If grouping is active and we haven't completed all levels, re-render group values for current level
          if (
            _groupState &&
            _groupState.enabled &&
            _groupState.selections &&
            _groupState.selections.length < (_groupState.levels || []).length
          ) {
            const levelIndex = _groupState.selections.length;
            const lvlInfo = getGroupLevelInfo(levelIndex);
            const headerKey = lvlInfo.key;
            const uniques = computeUniqueValues(filtered, headerKey);
            const summary = document.getElementById("group-summary");
            try {
              const totalExcel = Array.isArray(masterData)
                ? masterData.length
                : 0;
              const currentPool = Array.isArray(filtered) ? filtered.length : 0;
              const groupCount = Array.isArray(uniques) ? uniques.length : 0;
              if (summary) {
                summary.innerHTML = `
                  <div class="group-summary">
                    <div class="summary-title">Total items found in Excel: ${totalExcel}</div>
                    <div>Items matching search in current selection: <b>${currentPool}</b></div>
                    <div>Groups at this level: <b>${groupCount}</b></div>
                    <div class="summary-note">Tip: clear search to see all groups.</div>
                  </div>
                `;
              }
            } catch (e) {}
            partsList.innerHTML = uniques
              .map(
                (u) => `
              <li class="group-value-item" data-value-enc="${encodeURIComponent(
                String(u.value || ""),
              )}" data-header-enc="${encodeURIComponent(
                String(headerKey || ""),
              )}">
                <div class="part-info" style="flex: 1;">
                  <div class="group-card-title">${escapeHtml(
                    String(u.value || "").trim()
                      ? String(u.value)
                      : `No ${headerKey}`,
                  )}</div>
                  <div class="group-card-subtitle">Group value for <b>${escapeHtml(
                    headerKey,
                  )}</b></div>
                </div>
                  <div class="group-card-meta">
                    <div class="group-meta-badge">${u.count} items</div>
                  </div>
              </li>`,
              )
              .join("");
            partsList.querySelectorAll(".group-value-item").forEach((li) => {
              li.addEventListener("click", () => {
                const value = decodeURIComponent(li.dataset.valueEnc || "");
                const header = decodeURIComponent(li.dataset.headerEnc || "");
                const lvl = _groupState.selections.length;
                _groupState.selections[lvl] = {
                  levelIndex: lvl,
                  header,
                  value,
                };
                const nextIndex = lvl + 1;
                if (nextIndex >= _groupState.levels.length) {
                  const filteredParts = masterData.filter((r) =>
                    _groupState.selections.every(
                      (s) =>
                        String(r[s.header] || "") === String(s.value || ""),
                    ),
                  );
                  renderPartsList(filteredParts);
                } else {
                  renderGroupValues(nextIndex);
                }
              });
            });
          } else {
            renderPartsList(filtered);
          }
        }

        // Function to show PIN verification for master list (uses PIN + 5)
        async function showMasterListPinVerification() {
          return new Promise((resolve) => {
            const pinModal = document.getElementById("pin-modal");
            const pinInput = document.getElementById("pin-input");
            const pinError = document.getElementById("pin-error");
            const verifyBtn = document.getElementById("verify-pin-btn");
            const partsModal = document.getElementById("parts-modal");

            // Clear previous state but keep error states
            try {
              if (pinInput) pinInput.value = "";
            } catch (e) {}
            try {
              if (pinError) pinError.textContent = "";
            } catch (e) {}

            // Hide parts modal to ensure pin modal is fully accessible
            try {
              if (partsModal) partsModal.style.display = "none";
            } catch (e) {}
            try {
              if (pinModal) pinModal.style.zIndex = "9999";
            } catch (e) {}

            // Show the modal after a brief delay to ensure rendering
            setTimeout(() => {
              try {
                if (pinModal) pinModal.style.display = "block";
              } catch (e) {}
            }, 100);

            // Handle Enter key in PIN input
            const handleKeyPress = (e) => {
              if (e.key === "Enter") {
                verifyPin();
              }
            };

            // Verify PIN function
            const verifyPin = async () => {
              const pin = pinInput.value.trim();
              try {
                // Read the PIN from the file
                const response = await fetch("mod-base.txt");
                const savedPin = (await response.text()).trim();
                const basePin = atob(savedPin);
                const expectedPin = (
                  Number.parseInt(basePin, 10) + 5
                ).toString();

                if (pin === expectedPin) {
                  // Clear any scan failure UI so selecting a master item doesn't leave fields red
                  try {
                    document.getElementById("scan-data-value").textContent = "";
                    document
                      .getElementById("scan-data-value")
                      .classList.remove("scanned-success");
                  } catch (e) {}
                  try {
                    const sv = document.getElementById("scan-status-value");
                    if (sv) {
                      sv.textContent = "";
                      sv.classList.remove("ok");
                    }
                  } catch (e) {}
                  try {
                    const pc = document.getElementById(
                      "part-code-status-value",
                    );
                    if (pc) {
                      pc.textContent = "";
                      pc.classList.remove("ok");
                    }
                  } catch (e) {}
                  try {
                    if (
                      window.scanManager &&
                      typeof window.scanManager._showReadyState === "function"
                    ) {
                      window.scanManager._showReadyState();
                    } else {
                      const passEl = document.getElementById("pass-status");
                      if (passEl) {
                        passEl.textContent = "READY";
                        passEl.classList.remove("failed");
                      }
                    }
                  } catch (e) {}
                  try {
                    const btn = document.getElementById("btn-scan-data");
                    if (btn) btn.classList.remove("failed");
                  } catch (e) {}

                  // Remove any 'scan-failed' classes and inline red styles on inputs
                  try {
                    document.querySelectorAll(".scan-failed").forEach((el) => {
                      try {
                        el.classList.remove("scan-failed");
                        el.classList.remove("failed");
                        el.style.background = "";
                        el.style.color = "";
                      } catch (e) {}
                    });
                    const blink = document.getElementById("blink-overlay");
                    if (blink) blink.style.display = "none";
                  } catch (e) {}

                  pinModal.style.display = "none";
                  pinInput.removeEventListener("keypress", handleKeyPress);
                  verifyBtn.removeEventListener("click", verifyPin);
                  resolve(true);
                } else {
                  pinError.textContent = "Invalid PIN. Please try again.";
                  pinInput.value = "";
                  try {
                    window.safeFocus(pinInput);
                  } catch (e) {}
                }
              } catch (error) {
                console.error("Error verifying PIN:", error);
                pinError.textContent = "Error verifying PIN. Please try again.";
              }
            };

            // Set up event listeners
            pinInput.addEventListener("keypress", handleKeyPress);
            verifyBtn.addEventListener("click", verifyPin);
          });
        }

        // Event Listeners
        if (closeBtn) {
          closeBtn.addEventListener("click", hidePartsModal);
        } else {
          console.warn("parts modal close button not found");
        }

        if (modal) {
          modal.addEventListener("click", (e) => {
            if (e.target === modal) hidePartsModal();
          });
        }

        if (searchBox) {
          searchBox.addEventListener("input", (e) => {
            const searchTerm = e.target.value || "";
            // Save search term for the current level if grouping is active
            const levelIndex =
              _groupState && _groupState.selections
                ? _groupState.selections.length
                : 0;
            if (_groupState && Array.isArray(_groupState.searchTerms)) {
              _groupState.searchTerms[levelIndex] = searchTerm;
            }
            filterParts(searchTerm);
          });
        } else {
          console.warn("parts modal search box not found");
        }

        if (partsList) {
          partsList.addEventListener("click", async (e) => {
            const partItem = e.target.closest(".part-item");
            if (partItem) {
              // Show PIN verification before updating the part
              // Suppress scan-failed visuals during the master-selection PIN flow
              try {
                document.body.classList.add("suppress-scan-fail");
              } catch (e) {}
              let verified = false;
              try {
                verified = await showMasterListPinVerification();
              } finally {
                try {
                  document.body.classList.remove("suppress-scan-fail");
                } catch (e) {}
              }
              if (!verified) return;

              let rowIndex = Number(partItem.dataset.rowIndex);
              let partDetails =
                Number.isInteger(rowIndex) && rowIndex >= 0
                  ? masterData[rowIndex]
                  : null;

              // If we couldn't resolve by index, try resolving by primary value
              if (!partDetails) {
                const pv = partItem.dataset.primaryValue;
                if (pv) {
                  const foundIdx = masterData.findIndex((m) => {
                    const mv = getPrimaryValue(m) || "";
                    return mv && String(mv).trim() === String(pv).trim();
                  });
                  if (foundIdx >= 0) {
                    rowIndex = foundIdx;
                    partDetails = masterData[foundIdx];
                  }
                }
              }

              // Update the currently selected master row reference (use raw Excel row when available)
              const rawRow =
                Number.isInteger(rowIndex) &&
                rowIndex >= 0 &&
                masterRawRows[rowIndex]
                  ? masterRawRows[rowIndex]
                  : partDetails;
              currentSelectedRow = rawRow;
              try {
                // Store both the raw row and the exact excel row index for downstream consumers
                window.currentSelectedRow = rawRow;
                window.currentSelectedRowIndex =
                  Number.isInteger(rowIndex) && rowIndex >= 0 ? rowIndex : null;
                // If scanManager exists, propagate the exact row index and the targetPart reference
                if (window.scanManager && window.scanManager.scanSession) {
                  try {
                    window.scanManager.scanSession.targetPart = rawRow;
                    window.scanManager.scanSession.targetPartRowIndex =
                      window.currentSelectedRowIndex;
                  } catch (e) {}
                }
              } catch (e) {}

              // Populate all dynamic fields from selected raw row (prefer exact Excel values)
              if (rawRow) {
                settings.fields.forEach((field) => {
                  const input = document.getElementById(field.id);
                  if (input) {
                    input.value = getValueFromRow(rawRow, field.id) || "";
                  }
                });
                try {
                  // Ensure UI state reflects populated inputs (remove required/red markers)
                  normalizeAfterMasterSelect();
                } catch (e) {}
              }

              // Clear any regex / input highlights applied previously.
              try {
                // Remove scan-related classes from all configured input fields
                (settings.fields || []).forEach((f) => {
                  try {
                    const el = document.getElementById(f.id);
                    if (!el) return;
                    el.classList.remove(
                      "scan-active",
                      "scan-pending",
                      "scan-passed",
                      "scan-failed",
                    );
                    // remove inline highlight styles if present
                    el.style.background = "";
                    el.style.color = "";
                  } catch (e) {}
                });

                // Remove any DOM highlight markers inserted by regex-highlighting routines
                document
                  .querySelectorAll(".reg-highlight, .regex-highlight")
                  .forEach((node) => {
                    try {
                      const txt = node.textContent || "";
                      const parent = node.parentNode;
                      if (parent)
                        parent.replaceChild(document.createTextNode(txt), node);
                    } catch (e) {}
                  });
                // Extra safeguard: remove any lingering failure highlights that may have been applied elsewhere
                try {
                  // Remove scan-failed class from any fields and clear inline styles
                  document.querySelectorAll(".scan-failed").forEach((el) => {
                    try {
                      el.classList.remove("scan-failed");
                      el.classList.remove("failed");
                      el.style.background = "";
                      el.style.color = "";
                    } catch (e) {}
                  });
                  // Clear global failed indicators (pass-status, scan buttons)
                  try {
                    const passEl = document.getElementById("pass-status");
                    if (passEl) {
                      passEl.classList.remove("failed");
                      passEl.style.background = "";
                      passEl.style.color = "";
                    }
                  } catch (e) {}
                  try {
                    const scanBtn = document.getElementById("btn-scan-data");
                    if (scanBtn) {
                      scanBtn.classList.remove("failed");
                      scanBtn.style.background = "";
                      scanBtn.style.color = "";
                    }
                  } catch (e) {}
                  try {
                    const blink = document.getElementById("blink-overlay");
                    if (blink) blink.style.display = "none";
                  } catch (e) {}
                } catch (e) {}
              } catch (e) {}

              // Console-log the loaded row index and a full header->value map for debugging
              try {
                const rowIdx = Number.isInteger(rowIndex) ? rowIndex : -1;
                const headerMap = {};
                try {
                  (headerInfos || []).forEach((hi, i) => {
                    const key = (hi && (hi.name || hi.col)) || String(i);
                    let val = "";
                    try {
                      if (Array.isArray(rawRow)) {
                        val =
                          rawRow[i] !== undefined && rawRow[i] !== null
                            ? String(rawRow[i])
                            : "";
                      } else if (rawRow && typeof rawRow === "object") {
                        if (hi && hi.col && rawRow.hasOwnProperty(hi.col))
                          val = String(rawRow[hi.col] || "");
                        else if (
                          hi &&
                          hi.name &&
                          rawRow.hasOwnProperty(hi.name)
                        )
                          val = String(rawRow[hi.name] || "");
                        else {
                          // try common keys
                          val = String(
                            rawRow[
                              hi && hi.uniqueKey
                                ? hi.uniqueKey
                                : hi && hi.norm
                                  ? hi.norm
                                  : ""
                            ] || "",
                          );
                        }
                      }
                    } catch (e) {
                      val = "";
                    }
                    headerMap[key] = val;
                  });
                } catch (e) {}
                console.info("Master row loaded into inputs", {
                  rowIndex: rowIdx,
                  headerMap: headerMap,
                  rawRow: rawRow,
                });
                // also expose on debug object for later inspection
                try {
                  window._masterDataDebug = window._masterDataDebug || {};
                  window._masterDataDebug.lastSelected = {
                    rowIndex: rowIdx,
                    headerMap: headerMap,
                  };
                } catch (e) {}
              } catch (e) {
                console.warn("Failed to log selected master row", e);
              }

              // Reset scan data display (don't clear text, just remove success highlight)
              document
                .getElementById("scan-data-value")
                .classList.remove("scanned-success");
              document.getElementById("scan-status-value").textContent = "";
              document
                .getElementById("scan-status-value")
                .classList.remove("ok");
              document.getElementById("part-code-status-value").textContent =
                "";
              document
                .getElementById("part-code-status-value")
                .classList.remove("ok");
              if (
                window.scanManager &&
                typeof window.scanManager._showReadyState === "function"
              ) {
                window.scanManager._showReadyState();
              } else {
                document.getElementById("pass-status").textContent = "READY";
                document
                  .getElementById("pass-status")
                  .classList.remove("failed");
                document
                  .getElementById("pass-status")
                  .classList.remove("pass-box");
              }

              hidePartsModal();
              // Start multi-field scan session for the selected part if manager available
              try {
                if (
                  window.scanManager &&
                  typeof window.scanManager.startSessionForCurrentPart ===
                    "function"
                ) {
                  window.scanManager.startSessionForCurrentPart();
                }
              } catch (e) {
                console.error("Error starting scan session:", e);
              }
              // Post-start cleanup: ensure no fields remain marked as failed after selection
              try {
                // brief timeout to allow scanManager to apply its initial classes, then clear failures
                setTimeout(() => {
                  try {
                    document.querySelectorAll(".scan-failed").forEach((el) => {
                      try {
                        el.classList.remove("scan-failed");
                        el.classList.remove("failed");
                        el.style.background = "";
                        el.style.color = "";
                      } catch (e) {}
                    });
                    const passEl = document.getElementById("pass-status");
                    if (passEl) {
                      passEl.classList.remove("failed");
                      passEl.style.background = "";
                      passEl.style.color = "";
                    }
                    const scanBtn = document.getElementById("btn-scan-data");
                    if (scanBtn) {
                      scanBtn.classList.remove("failed");
                      scanBtn.style.background = "";
                      scanBtn.style.color = "";
                    }
                    const blink = document.getElementById("blink-overlay");
                    if (blink) blink.style.display = "none";
                    // ensure any failure icons reset
                    document
                      .querySelectorAll("[data-failed-icon]")
                      .forEach((ic) => {
                        try {
                          ic.style.background = "";
                        } catch (e) {}
                      });
                  } catch (e) {}
                }, 40);
              } catch (e) {}
            }
          });
        } else {
          console.warn("parts modal parts list not found");
        }

        // Settings modal handling
        async function openSettingsModal() {
          // Ensure master data (and headers) are loaded so mappings can use detected headers
          try {
            await loadMasterData();
          } catch (e) {
            // continue - loadMasterData handles its own errors
          }

          loadSettings();
          const modal = document.getElementById("settings-modal");
          const container = document.getElementById("mappings-container");
          const primaryContainer = document.getElementById(
            "primary-field-container",
          );
          const displayContainer = document.getElementById(
            "display-field-container",
          );
          const scanOpSelect = document.getElementById("scan-op-select");

          // Remove any previously injected Grouping UI blocks (prevents duplicates)
          try {
            document
              .querySelectorAll("#grouping-container")
              .forEach((el) => el.remove());
          } catch (e) {}

          // Clear UI
          container.innerHTML = "";
          if (primaryContainer) primaryContainer.innerHTML = "";
          if (displayContainer) displayContainer.innerHTML = "";

          // Build a row for each field with label input, header dropdown, and remove button
          // Use headerInfos (column-aware) and include any existing mapped headers to avoid data loss
          const headersList = (headerInfos || []).slice();
          // Also include any headers referenced in settings.fields that might not be present
          (settings.fields || []).forEach((f) => {
            if (
              f.header &&
              !headersList.find(
                (h) => h.name === f.header && h.col === f.headerCol,
              )
            ) {
              headersList.push({
                name: f.header,
                col: f.headerCol || "",
                norm: normalizeHeader(f.header || ""),
              });
            }
          });

          // Helper: create a mapping row element for a given field or header
          function createMappingRow(field) {
            const row = document.createElement("div");
            row.style.display = "flex";
            row.style.gap = "8px";
            row.style.alignItems = "center";
            row.dataset.fieldId = field.id || `field_${Date.now()}`;

            const labelInput = document.createElement("input");
            labelInput.type = "text";
            labelInput.value = field.label || "Field";
            labelInput.style.minWidth = "140px";
            labelInput.placeholder = "Label";

            const select = document.createElement("select");
            select.style.flex = "1";
            if (headersList.length === 0) {
              const opt = document.createElement("option");
              opt.value = "";
              opt.textContent = "(no headers detected)";
              select.appendChild(opt);
            } else {
              headersList.forEach((h) => {
                const opt = document.createElement("option");
                opt.value = h.col || h.name || "";
                opt.textContent =
                  (h.col ? h.col + " â€” " : "") + (h.name || "(empty)");
                // pre-select if this field maps to the header
                if (
                  (field.headerCol && field.headerCol === h.col) ||
                  (!field.headerCol && field.header === h.name)
                )
                  opt.selected = true;
                select.appendChild(opt);
              });
            }

            // Track mapped header info on the row for reliable removal
            const resolveSelectedHeader = () => {
              const sel = select.value || "";
              const hi =
                (headersList || []).find((h) => h.col === sel) ||
                (headersList || []).find((h) => h.name === sel) ||
                null;
              if (hi) {
                row.dataset.headerName = hi.name || "";
                row.dataset.headerCol = hi.col || "";
                row.dataset.headerNorm =
                  hi.norm || normalizeHeader(hi.name || "");
              } else if (field.header) {
                row.dataset.headerName = field.header || "";
                row.dataset.headerCol = field.headerCol || "";
                row.dataset.headerNorm = normalizeHeader(field.header || "");
              } else {
                row.dataset.headerName = "";
                row.dataset.headerCol = "";
                row.dataset.headerNorm = "";
              }
            };
            resolveSelectedHeader();
            select.addEventListener("change", resolveSelectedHeader);

            const removeBtn = document.createElement("button");
            removeBtn.textContent = "âœ•";
            removeBtn.style.padding = "4px 8px";
            removeBtn.style.backgroundColor = "#ff3b30";
            removeBtn.style.color = "white";
            removeBtn.style.border = "none";
            removeBtn.style.borderRadius = "4px";
            removeBtn.style.cursor = "pointer";
            removeBtn.onclick = () => {
              settings.removedHeaders = settings.removedHeaders || [];
              const name = row.dataset.headerName || "";
              const col = row.dataset.headerCol || "";
              const norm =
                row.dataset.headerNorm || normalizeHeader(name || "");
              if (name || col) {
                if (
                  !settings.removedHeaders.find(
                    (r) => (r.col || "") === col && (r.name || "") === name,
                  )
                ) {
                  settings.removedHeaders.push({
                    name: name,
                    col: col,
                    norm: norm,
                  });
                }
              } else {
                // Try a normalized lookup against headerInfos as a last resort
                const sel = select.value || "";
                const hi =
                  (headerInfos || []).find((h) => h.col === sel) ||
                  (headerInfos || []).find(
                    (h) =>
                      normalizeHeader(h.name || "") ===
                      normalizeHeader(sel || ""),
                  );
                if (
                  hi &&
                  !settings.removedHeaders.find(
                    (r) => r.col === hi.col && r.name === hi.name,
                  )
                ) {
                  settings.removedHeaders.push({
                    name: hi.name,
                    col: hi.col,
                    norm: hi.norm,
                  });
                }
              }
              updateHiddenList();
              row.remove();
              rebuildPrimaryDisplay();
            };

            row.appendChild(labelInput);
            row.appendChild(select);
            row.appendChild(removeBtn);
            return row;
          }

          // Create initial mapping rows
          settings.fields.forEach((field) => {
            container.appendChild(createMappingRow(field));
          });

          // Add "Add Field" button that uses the same row creator
          const addBtn = document.createElement("button");
          addBtn.textContent = "+ Add Field";
          addBtn.style.marginTop = "8px";
          addBtn.style.padding = "8px 16px";
          addBtn.style.backgroundColor = "#3399ff";
          addBtn.style.color = "white";
          addBtn.style.border = "none";
          addBtn.style.borderRadius = "6px";
          addBtn.style.cursor = "pointer";
          addBtn.onclick = () => {
            const newField = {
              id: `field_${Date.now()}`,
              label: "New Field",
              header: "",
              headerCol: "",
            };
            const row = createMappingRow(newField);
            container.insertBefore(row, addBtn);
            rebuildPrimaryDisplay();
          };
          container.appendChild(addBtn);

          // Function to rebuild primary and display checkbox lists from current mapping rows
          function rebuildPrimaryDisplay() {
            if (!primaryContainer || !displayContainer) return;
            primaryContainer.innerHTML = "";
            displayContainer.innerHTML = "";
            const rowsNow = container.querySelectorAll("div[data-field-id]");
            rowsNow.forEach((r) => {
              const fid = r.dataset.fieldId;
              const label =
                (r.querySelector('input[type="text"]') || {}).value || fid;

              const pwrap = document.createElement("label");
              pwrap.style.display = "flex";
              pwrap.style.alignItems = "center";
              pwrap.style.gap = "8px";
              pwrap.style.cursor = "pointer";
              const pchk = document.createElement("input");
              pchk.type = "checkbox";
              pchk.value = fid;
              pchk.id = `prim_chk_${fid}`;
              if (
                settings.primaryFields &&
                settings.primaryFields.includes(fid)
              )
                pchk.checked = true;
              const pspan = document.createElement("span");
              pspan.textContent = label;
              pwrap.appendChild(pchk);
              pwrap.appendChild(pspan);
              primaryContainer.appendChild(pwrap);

              const dwrap = document.createElement("label");
              dwrap.style.display = "flex";
              dwrap.style.alignItems = "center";
              dwrap.style.gap = "8px";
              dwrap.style.cursor = "pointer";
              const dchk = document.createElement("input");
              dchk.type = "checkbox";
              dchk.value = fid;
              dchk.id = `disp_chk_${fid}`;
              if (
                Array.isArray(settings.displayFields) &&
                settings.displayFields.includes(fid)
              )
                dchk.checked = true;
              else if (!settings.displayFields && settings.displayField === fid)
                dchk.checked = true;
              const dspan = document.createElement("span");
              dspan.textContent = label;
              dwrap.appendChild(dchk);
              dwrap.appendChild(dspan);
              displayContainer.appendChild(dwrap);
            });
          }

          // initial build
          rebuildPrimaryDisplay();

          // Set scan operation
          if (settings.scanOperation)
            scanOpSelect.value = settings.scanOperation;

          // Update hidden headers UI
          function updateHiddenList() {
            const hiddenList = document.getElementById("hidden-headers-list");
            // Deduplicate removedHeaders by col+name (normalize keys)
            settings.removedHeaders = (settings.removedHeaders || []).filter(
              (v, i, arr) => {
                const key = `${(v.col || "").trim()}||${(v.name || "").trim()}`;
                return (
                  arr.findIndex(
                    (x) =>
                      `${(x.col || "").trim()}||${(x.name || "").trim()}` ===
                      key,
                  ) === i
                );
              },
            );
            hiddenList.innerHTML = "";
            (settings.removedHeaders || []).forEach((h, idx) => {
              const row = document.createElement("div");
              row.style.display = "flex";
              row.style.justifyContent = "space-between";
              row.style.alignItems = "center";
              row.style.padding = "6px";

              const txt = document.createElement("div");
              txt.textContent =
                (h.col ? h.col + " â€” " : "") + (h.name || "(empty)");
              const btns = document.createElement("div");

              const restore = document.createElement("button");
              restore.textContent = "Restore";
              restore.style.marginRight = "6px";
              restore.style.padding = "4px 8px";
              restore.style.cursor = "pointer";
              restore.onclick = () => {
                // Remove from removedHeaders
                settings.removedHeaders = (
                  settings.removedHeaders || []
                ).filter((x) => !(x.col === h.col && x.name === h.name));
                // Create a mapping row for this header
                const f = {
                  id: `field_${Date.now()}`,
                  label: h.name || h.col || "Restored",
                  header: h.name,
                  headerCol: h.col,
                };
                const newRow = createMappingRow(f);
                container.insertBefore(newRow, addBtn);
                rebuildPrimaryDisplay();
                updateHiddenList();
              };

              const removePerm = document.createElement("button");
              removePerm.textContent = "Delete";
              removePerm.style.padding = "4px 8px";
              removePerm.style.background = "#660000";
              removePerm.style.color = "white";
              removePerm.style.cursor = "pointer";
              removePerm.onclick = () => {
                settings.removedHeaders = (
                  settings.removedHeaders || []
                ).filter((x) => !(x.col === h.col && x.name === h.name));
                updateHiddenList();
              };

              btns.appendChild(restore);
              btns.appendChild(removePerm);
              row.appendChild(txt);
              row.appendChild(btns);
              hiddenList.appendChild(row);
            });
          }

          updateHiddenList();

          // --- Grouping Levels UI ---
          (function initGroupingUI() {
            // If a previous instance exists, remove it (defensive)
            try {
              document
                .querySelectorAll("#grouping-container")
                .forEach((el) => el.remove());
            } catch (e) {}

            // Create container and controls for grouping levels
            const groupingContainer = document.createElement("div");
            groupingContainer.id = "grouping-container";
            groupingContainer.style.marginTop = "12px";
            groupingContainer.innerHTML = `
              <div style="color:#fff; display:block; margin-bottom:6px">Grouping Levels (ordered)</div>
              <div id="grouping-levels" style="display:flex; flex-direction:column; gap:6px; margin-bottom:8px"></div>
              <div style="display:flex; gap:8px;">
                <button id="add-group-level" style="padding:6px 10px; background:#3399ff; color:white; border:none; border-radius:4px; cursor:pointer">+ Add Level</button>
                <span style="color:#fff; align-self:center; font-size:12px">Choose fields and arrange order for Levelâ€‘1 â†’ Levelâ€‘N grouping.</span>
              </div>
            `;

            // Insert grouping UI after mappings container
            try {
              container.parentNode.insertBefore(
                groupingContainer,
                container.nextSibling,
              );
            } catch (e) {}

            const levelsDiv =
              groupingContainer.querySelector("#grouping-levels");
            const addBtn = groupingContainer.querySelector("#add-group-level");

            function createGroupingRow(selectedFieldId) {
              const row = document.createElement("div");
              row.style.display = "flex";
              row.style.gap = "6px";
              row.style.alignItems = "center";
              row.dataset.groupLevel = Date.now();

              const select = document.createElement("select");
              select.style.flex = "1";
              (settings.fields || []).forEach((f) => {
                const opt = document.createElement("option");
                opt.value = f.id;
                opt.textContent = f.label || f.id;
                if (f.id === selectedFieldId) opt.selected = true;
                select.appendChild(opt);
              });

              const up = document.createElement("button");
              up.textContent = "â†‘";
              up.title = "Move up";
              up.style.padding = "4px 8px";

              const down = document.createElement("button");
              down.textContent = "â†“";
              down.title = "Move down";
              down.style.padding = "4px 8px";

              const remove = document.createElement("button");
              remove.textContent = "âœ•";
              remove.title = "Remove level";
              remove.style.padding = "4px 8px";
              remove.style.background = "#ff3b30";
              remove.style.color = "#fff";

              up.onclick = () => {
                const prev = row.previousElementSibling;
                if (prev) levelsDiv.insertBefore(row, prev);
              };
              down.onclick = () => {
                const next = row.nextElementSibling;
                if (next) levelsDiv.insertBefore(next, row);
              };
              remove.onclick = () => row.remove();

              row.appendChild(select);
              row.appendChild(up);
              row.appendChild(down);
              row.appendChild(remove);
              return row;
            }

            // Populate existing grouping fields if present
            try {
              const existing = Array.isArray(settings.groupingFields)
                ? settings.groupingFields
                : [];
              if (existing.length > 0) {
                existing.forEach((g) => {
                  const fid = g.id || g.fieldId || g.field || "";
                  levelsDiv.appendChild(createGroupingRow(fid));
                });
              }
            } catch (e) {}

            addBtn.addEventListener("click", () => {
              levelsDiv.appendChild(
                createGroupingRow(
                  (settings.fields &&
                    settings.fields[0] &&
                    settings.fields[0].id) ||
                    "",
                ),
              );
            });
          })();

          // Show modal
          modal.style.display = "block";
        }

        // Save settings from modal
        function saveSettingsFromModal() {
          const container = document.getElementById("mappings-container");
          const rows = container.querySelectorAll("div[data-field-id]");

          // Rebuild fields array from UI (store both header name and column address when available)
          settings.fields = [];
          rows.forEach((row) => {
            const fieldId = row.dataset.fieldId;
            const labelInput = row.querySelector('input[type="text"]');
            const select = row.querySelector("select");
            if (labelInput && select) {
              const selVal = select.value || "";
              // Prefer dataset values stored on the row (most reliable)
              let headerName = row.dataset.headerName || "";
              let headerCol = row.dataset.headerCol || "";
              if (!headerName && !headerCol) {
                // Try to resolve via headerInfos or headersList with normalization
                const normSel = normalizeHeader(selVal || "");
                const hi =
                  (headerInfos || []).find((h) => h.col === selVal) ||
                  (headerInfos || []).find((h) => h.name === selVal) ||
                  (headerInfos || []).find((h) => h.norm === normSel) ||
                  (headersList || []).find(
                    (h) =>
                      h.name === selVal ||
                      h.col === selVal ||
                      h.norm === normSel,
                  );
                if (hi) {
                  headerName = hi.name || "";
                  headerCol = hi.col || "";
                } else if (selVal && /^[A-Z]+$/.test(selVal)) {
                  headerCol = selVal;
                  headerName = "";
                } else {
                  headerName = selVal;
                  headerCol = "";
                }
              }
              settings.fields.push({
                id: fieldId,
                label: labelInput.value || "Field",
                header: headerName,
                headerCol: headerCol,
              });
            }
          });

          // Read primary scan field(s), display field, and scan operation
          const primaryContainerElem = document.getElementById(
            "primary-field-container",
          );
          const selectedPrimary = primaryContainerElem
            ? Array.from(
                primaryContainerElem.querySelectorAll(
                  'input[type="checkbox"]:checked',
                ),
              ).map((o) => o.value)
            : [];
          settings.primaryFields = selectedPrimary.length
            ? selectedPrimary
            : settings.fields[0]
              ? [settings.fields[0].id]
              : [];
          // Read display fields from checkboxes (allow multiple)
          const displayContainerElem = document.getElementById(
            "display-field-container",
          );
          const selectedDisplay = displayContainerElem
            ? Array.from(
                displayContainerElem.querySelectorAll(
                  'input[type="checkbox"]:checked',
                ),
              ).map((o) => o.value)
            : [];
          settings.displayFields = selectedDisplay.length
            ? selectedDisplay
            : settings.fields[0]
              ? [settings.fields[0].id]
              : [];
          // keep legacy single value for compatibility
          settings.displayField = settings.displayFields[0] || "";
          settings.scanOperation =
            document.getElementById("scan-op-select").value || "equals";
          // Read showMultiScanPanel checkbox state
          const showMulti = document.getElementById("show-multi-scan-panel");
          if (showMulti) settings.showMultiScanPanel = !!showMulti.checked;
          // Read grouping levels from the Grouping UI if present
          try {
            const levelsDiv = document.getElementById("grouping-levels");
            if (levelsDiv) {
              const rows = Array.from(
                levelsDiv.querySelectorAll("div[data-group-level]"),
              );
              const groupingFields = rows
                .map((r) => {
                  const sel = r.querySelector("select");
                  const fid = sel ? sel.value : null;
                  if (!fid) return null;
                  const f = (settings.fields || []).find(
                    (x) => x.id === fid,
                  ) || { id: fid, label: fid };
                  return {
                    id: f.id,
                    label: f.label,
                    header: f.header,
                    headerCol: f.headerCol,
                  };
                })
                .filter((x) => x && x.id);
              settings.groupingFields = groupingFields;
            }
          } catch (e) {}

          saveSettings();
          rebuildInputUI();
          document.getElementById("settings-modal").style.display = "none";
          // Apply visibility immediately to the multi-scan panel if manager exists
          try {
            if (window.scanManager) {
              const panel = document.getElementById("multi-scan-panel");
              if (panel)
                panel.style.display =
                  settings.showMultiScanPanel === false ? "none" : "block";
              try {
                window.scanManager._updatePanelStatus &&
                  window.scanManager._updatePanelStatus();
              } catch (e) {}
            }
          } catch (e) {}
        } // Hook up settings buttons
        document
          .getElementById("btn-settings")
          .addEventListener("click", () => {
            openSettingsModal();
          });

        // Hide settings button if showSettings is false
        if (!showSettings) {
          document.getElementById("btn-settings").style.display = "none";
        }

        document
          .getElementById("close-settings")
          .addEventListener(
            "click",
            () =>
              (document.getElementById("settings-modal").style.display =
                "none"),
          );
        document
          .getElementById("cancel-settings")
          .addEventListener(
            "click",
            () =>
              (document.getElementById("settings-modal").style.display =
                "none"),
          );

        // Refresh header mappings from master Excel
        document
          .getElementById("refresh-settings")
          .addEventListener("click", async () => {
            // Prevent the auto-open of the Master modal during refresh
            window._suppressAutoOpenMasterOnLoad = true;
            try {
              await openSettingsModal();
              showNotification("Headers refreshed from master Excel", "info");
            } catch (e) {
              console.error("Refresh headers failed:", e);
              showNotification("Failed to refresh headers", "error");
            } finally {
              window._suppressAutoOpenMasterOnLoad = false;
            }
          });
        document
          .getElementById("save-settings")
          .addEventListener("click", saveSettingsFromModal);

        // Handle buttons
        document
          .getElementById("btn-master")
          .addEventListener("click", showPartsModal);
        document
          .getElementById("btn-scan-data")
          .addEventListener("click", function () {
            const manualCode = prompt("Enter part code:");
            if (manualCode) {
              // Clean manual entry just in case
              const cleanedCode = manualCode.replace(/Enter$/, "");
              handleScan(cleanedCode);
            }
          });
        document
          .getElementById("btn-history")
          .addEventListener("click", async function () {
            // Load today's scan logs from file
            const todaysLogs = await loadTodaysScanLogs();

            // Build dynamic column list using configured fields and include scan-by
            const configuredHeaders = (settings.fields || []).map(
              (f) => f.header || f.label || f.id,
            );
            let columns = [
              "Date",
              "Time",
              ...configuredHeaders,
              "scan-by",
              "Scanned Code",
              "Scanner",
              "Status",
            ];
            // Deduplicate while preserving order
            const seenCols = new Set();
            columns = columns.filter((c) => {
              if (seenCols.has(c)) return false;
              seenCols.add(c);
              return true;
            });

            const headerHtml = columns.map((c) => `<th>${c}</th>`).join("");

            const rowsHtml = todaysLogs
              .map((log) => {
                const cls =
                  log.matchStatus === "MATCHED" ? "match" : "no-match";
                const cells = columns
                  .map((col) => {
                    if (col === "Date")
                      return `<td>${log.timestamp.toLocaleDateString(
                        "en-GB",
                      )}</td>`;
                    if (col === "Time")
                      return `<td>${log.timestamp.toLocaleTimeString(
                        "en-GB",
                      )}</td>`;
                    // Prefer raw saved value (from file), fallback to computed fields
                    const raw = log.raw || {};
                    if (raw.hasOwnProperty(col)) return `<td>${raw[col]}</td>`;
                    if (col === "Scanned Code")
                      return `<td>${log.scannedCode || ""}</td>`;
                    if (col === "Scanner")
                      return `<td>${log.scannerInfo || ""}</td>`;
                    if (col === "Status")
                      return `<td>${log.matchStatus || ""}</td>`;
                    if (col === "scan-by")
                      return `<td>${
                        raw["scan-by"] ||
                        raw["Scanner"] ||
                        log.scannerInfo ||
                        ""
                      }</td>`;
                    // Any configured field that wasn't in raw -> try common named properties
                    if (
                      col ===
                      (settings.displayField &&
                        (
                          (settings.fields || []).find(
                            (f) => f.id === settings.displayField,
                          ) || {}
                        ).header)
                    )
                      return `<td>${log.partCode || ""}</td>`;
                    if (col === "Part Name")
                      return `<td>${log.partName || ""}</td>`;
                    if (col === "Customer")
                      return `<td>${log.customer || ""}</td>`;
                    return `<td></td>`;
                  })
                  .join("");

                return `<tr class="${cls}">${cells}</tr>`;
              })
              .join("");

            // History modal content
            const historyHtml = `
          ${
            todaysLogs.length === 0
              ? '<div style="text-align: center; color: #fff; padding: 20px;">No scan history available for today</div>'
              : ""
          }
          <div class="modal-header">
            <h2 class="modal-title">Today's Scan History</h2>
            <button id="export-logs">Export</button>
            <button class="close-modal">&times;</button>
          </div>
          <div class="scan-logs">
            <table class="logs-table">
              <thead>
                <tr>
                  ${headerHtml}
                </tr>
              </thead>
              <tbody>
                ${rowsHtml}
              </tbody>
            </table>
          </div>
        `;

            const historyModal = document.createElement("div");
            historyModal.className = "modal";
            historyModal.innerHTML = `
          <div class="modal-content">
            ${historyHtml}
          </div>
        `;

            document.body.appendChild(historyModal);
            historyModal.style.display = "block";

            // Handle close button and outside click
            const closeBtn = historyModal.querySelector(".close-modal");
            closeBtn.addEventListener("click", () => {
              try {
                if (historyModal && historyModal.remove) historyModal.remove();
                else if (historyModal && historyModal.parentNode)
                  historyModal.parentNode.removeChild(historyModal);
              } catch (e) {}
            });
            historyModal.addEventListener("click", (e) => {
              if (e.target === historyModal) {
                try {
                  if (historyModal && historyModal.remove)
                    historyModal.remove();
                  else if (historyModal && historyModal.parentNode)
                    historyModal.parentNode.removeChild(historyModal);
                } catch (e) {}
              }
            });

            // Handle export button - export today's logs
            const exportBtn = historyModal.querySelector("#export-logs");
            if (exportBtn) {
              exportBtn.addEventListener("click", async () => {
                if (todaysLogs.length === 0) {
                  showNotification("No logs to export for today", "error");
                  return;
                }

                // Prepare today's logs for export using configured fields
                const logsToExport = todaysLogs.map((log) => {
                  const row = {};
                  row["Date"] = log.timestamp.toLocaleDateString("en-GB");
                  row["Time"] = log.timestamp.toLocaleTimeString("en-GB");

                  (settings.fields || []).forEach((f) => {
                    const header = f.header || f.label || f.id;
                    row[header] = (log.raw && log.raw[header]) || "";
                  });

                  row["scan-by"] =
                    (log.raw && (log.raw["scan-by"] || log.raw["Scanner"])) ||
                    log.scannerInfo ||
                    "";
                  row["Scanned Code"] = log.scannedCode;
                  row["Scanner"] = log.scannerInfo;
                  row["Status"] = log.matchStatus;
                  return row;
                });

                // Sort by date and time descending (newest first)
                logsToExport.sort((a, b) => {
                  const dateA = new Date(
                    a["Date"].split("/").reverse().join("-") + " " + a["Time"],
                  );
                  const dateB = new Date(
                    b["Date"].split("/").reverse().join("-") + " " + b["Time"],
                  );
                  return dateB - dateA;
                });

                try {
                  const result = await ipcRenderer.invoke(
                    "write-logs",
                    logsToExport,
                  );
                  console.log(
                    `Successfully exported ${logsToExport.length} today's logs to ${result.filePath}`,
                  );
                  showNotification(
                    `Successfully exported ${logsToExport.length} today's scan logs`,
                    "info",
                  );
                } catch (error) {
                  console.error("Error exporting today's logs:", error);
                  showNotification(
                    "Error exporting logs. Please try again.",
                    "error",
                  );
                }
              });
            }
          });

        // Initialize data and timestamp after all scripts/resources load
        window.addEventListener("load", async () => {
          await loadMasterData();
          updateTimestamp();
        });

        // New code to enforce initial blank and red highlight on required fields and show popup on scan or click if no part selected
        function markRequiredFields() {
          const primaryInput = document.getElementById(getPrimaryFieldId());
          const scanByInput = document.getElementById("scan-by");

          // If primary scan field is empty, mark all inputs as required (red border) and blank
          if (!primaryInput || primaryInput.value.trim() === "") {
            settings.fields.forEach((field) => {
              const input = document.getElementById(field.id);
              if (input) {
                input.value = "";
                input.classList.add("required");
              }
            });
            if (scanByInput) {
              scanByInput.value = "";
              scanByInput.classList.add("required");
            }
          } else {
            settings.fields.forEach((field) => {
              const input = document.getElementById(field.id);
              if (input) input.classList.remove("required");
            });
            if (scanByInput) scanByInput.classList.remove("required");
          }
        }

        // Open master modal if primary scan field is not selected
        async function checkPartSelectedBeforeAction() {
          const primaryInput = document.getElementById(getPrimaryFieldId());
          if (!primaryInput || !primaryInput.value.trim()) {
            // Open master modal
            document.getElementById("btn-master").click();
            return false;
          }
          return true;
        }

        // Override scan button click to check part selection first
        document
          .getElementById("btn-scan-data")
          .addEventListener("click", async function (event) {
            const allowed = await checkPartSelectedBeforeAction();
            if (!allowed) {
              event.preventDefault();
              return;
            }
            // If allowed, prompt for manual code input as before
            const manualCode = prompt("Enter part code:");
            if (manualCode) {
              const cleanedCode = manualCode.replace(/Enter$/, "");
              handleScan(cleanedCode);
            }
          });

        // Override scan input via keyboard (handleScan) to check part selection first
        const originalHandleScan = handleScan;
        handleScan = async function (scannedCode) {
          const allowed = await checkPartSelectedBeforeAction();
          if (!allowed) {
            return;
          }
          await originalHandleScan(scannedCode);
        };

        // On initial load, clear part code, part name, customer, scan by and mark required fields red
        function clearInitialFields() {
          settings.fields.forEach((field) => {
            const input = document.getElementById(field.id);
            if (input) input.value = "";
          });
          const scanBy = document.getElementById("scan-by");
          if (scanBy) scanBy.value = "XXXXX";
          document.getElementById("scan-data-value").textContent = "";
          document.getElementById("scan-status-value").textContent = "";
          document.getElementById("scan-status-value").classList.remove("ok");
          document.getElementById("part-code-status-value").textContent = "";
          document
            .getElementById("part-code-status-value")
            .classList.remove("ok");
          document.getElementById("pass-status").textContent = "READY";
          document
            .getElementById("pass-status")
            .classList.remove("failed", "pass-box");
          document.getElementById("scan-qty").value = "00000";

          markRequiredFields();
        }

        // Call clearInitialFields after master data is loaded
        const originalLoadMasterData = loadMasterData;
        loadMasterData = async function () {
          await originalLoadMasterData();
          clearInitialFields();
          // Initially open master modal to select part code first, if data loaded
          if (!window._suppressAutoOpenMasterOnLoad && masterData.length > 0) {
            document.getElementById("btn-master").click();
          }
        };
      });
    </script>

    <script>
      // Initialize the Show Multi-scan Panel checkbox and persist changes immediately
      document.addEventListener("DOMContentLoaded", function () {
        try {
          const chk = document.getElementById("show-multi-scan-panel");
          if (!chk) return;
          // initialize checked state from settings (default true)
          try {
            chk.checked =
              typeof settings.showMultiScanPanel === "undefined"
                ? true
                : !!settings.showMultiScanPanel;
          } catch (e) {
            chk.checked = true;
          }

          // apply initial visibility to the panel if present
          try {
            const panel = document.getElementById("multi-scan-panel");
            if (panel) panel.style.display = chk.checked ? "block" : "none";
          } catch (e) {}

          // Persist and apply change immediately when user toggles the checkbox
          chk.addEventListener("change", function () {
            try {
              settings.showMultiScanPanel = !!chk.checked;
              // persist setting to disk
              try {
                saveSettings();
              } catch (e) {
                console.error("Failed to save settings on toggle", e);
              }
              // show/hide the actual panel element
              try {
                const panel = document.getElementById("multi-scan-panel");
                if (panel)
                  panel.style.display = settings.showMultiScanPanel
                    ? "block"
                    : "none";
              } catch (e) {}
              // update visuals if manager present
              try {
                if (
                  window.scanManager &&
                  typeof window.scanManager._updatePanelStatus === "function"
                )
                  window.scanManager._updatePanelStatus();
              } catch (e) {}
            } catch (e) {
              console.error("Error handling showMultiScanPanel change", e);
            }
          });
        } catch (e) {
          console.error("init show-multi-scan-panel failed", e);
        }
      });
    </script>
  </head>
  <body>
    <div id="app-container" class="container">
      <header id="main-header" class="header">
        <div id="company-logo" class="logo">
          <img
            id="logo-img"
            src="https://gadglobal.co.in/wp-content/uploads/2020/10/1WhatsApp-Image-2020-10-09-at-12.38.18-PM-e1602228066541.jpeg"
            alt="GAD Logo"
          />
          <span id="logo-text" class="logo-text">GAD</span>
        </div>
        <h1 id="page-title">Crimping Terminal Verification System</h1>
        <nav id="nav-buttons" class="buttons">
          <button id="btn-master">Master</button>
          <button id="btn-history">History</button>
          <button id="btn-settings">Settings</button>
          <button id="btn-start-server" class="nav-button">Server</button>
          <button id="btn-update-master" class="nav-button">
            Update master
          </button>
        </nav>
      </header>

      <main id="main-content" class="main">
        <section id="input-section" class="input-section">
          <h2 id="input-title">Input Data</h2>

          <!-- Dynamic fields will be inserted here by rebuildInputUI -->

          <div id="scan-by-row" class="row">
            <label for="scan-by">Scan By</label>
            <input
              type="text"
              id="scan-by"
              value=""
              title="Click to set scanner name"
              style="cursor: pointer"
            />
          </div>

          <div id="verification-section" class="verification">
            <h3 id="verification-title">Verification Status</h3>

            <div id="scan-data-row" class="verify-row">
              <button id="btn-scan-data">Scan Data</button>
              <div id="scan-data-value" class="value"></div>
            </div>

            <div id="scan-status-row" class="verify-row">
              <button id="btn-scan-status">Scan Status</button>
              <div id="scan-status-value" class="value"></div>
            </div>

            <div id="part-code-status-row" class="verify-row">
              <button id="btn-part-code-status">Part Code Status</button>
              <div id="part-code-status-value" class="value"></div>
            </div>
          </div>
        </section>

        <aside id="status-section" class="right-section">
          <div
            id="datetime-box"
            style="
              display: flex;
              gap: 8px;
              flex-wrap: wrap;
              align-items: center;
            "
          >
            <div id="scan-qty-box" class="info-box">
              <label for="scan-qty">Scan Qty</label>
              <input type="text" id="scan-qty" value="00000" readonly />
            </div>

            <div id="date-box" class="info-box">
              <label for="date">Date</label>
              <input type="text" id="date" value="13-09-2025" readonly />
            </div>

            <div id="time-box" class="info-box">
              <label for="time">Time</label>
              <input type="text" id="time" value="15:44:22" readonly />
            </div>
          </div>

          <div id="overall-status" class="status">Over All Scan Status</div>
          <div
            style="
              flex: 1;
              display: flex;
              flex-direction: column;
              margin-top: 10px;
            "
          >
            <div id="pass-status">READY</div>
          </div>
        </aside>
      </main>
    </div>

    <audio id="error-sound" src="error.mp3" preload="auto"></audio>

    <!-- PIN Verification Modal -->
    <div id="pin-modal" class="modal" style="z-index: 9999">
      <div class="modal-content" style="max-width: 500px">
        <div id="blink-overlay" class="blink-overlay"></div>
        <div class="modal-header">
          <h2 class="modal-title">Verification Required</h2>
        </div>
        <div style="padding: 20px; text-align: center">
          <p style="margin-bottom: 20px; font-size: 16px">
            Please enter the security PIN to continue:
          </p>
          <input
            type="password"
            id="pin-input"
            class="search-box"
            style="font-size: 24px; text-align: center; letter-spacing: 5px"
            maxlength="6"
            tabindex="0"
          />
          <p
            id="pin-error"
            style="color: var(--danger); min-height: 20px; margin: 10px 0 0 0"
          ></p>
          <div style="margin-top: 30px">
            <button
              id="verify-pin-btn"
              style="
                padding: 10px 30px;
                font-size: 16px;
                background-color: var(--primary);
                color: var(--primary-contrast);
                border: none;
                border-radius: 4px;
                cursor: pointer;
              "
            >
              Verify PIN
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- Scanner Name Modal -->
    <dialog
      id="scanner-modal"
      class="modal"
      style="z-index: 2000"
      aria-modal="true"
      aria-labelledby="scanner-modal-title"
    >
      <div class="modal-content" style="max-width: 500px">
        <div class="modal-header">
          <h2 id="scanner-modal-title" class="modal-title">Set Scanner Name</h2>
        </div>
        <div style="padding: 20px; text-align: center">
          <p style="margin-bottom: 20px; font-size: 16px">
            Enter the scanning person's name:
          </p>
          <input
            type="text"
            id="scanner-input"
            class="search-box"
            style="font-size: 22px; text-align: center"
            maxlength="50"
          />
          <p
            id="scanner-error"
            style="color: var(--danger); min-height: 20px; margin: 10px 0 0 0"
          ></p>
          <div
            style="
              margin-top: 30px;
              display: flex;
              gap: 10px;
              justify-content: center;
            "
          >
            <button
              id="save-scanner-btn"
              style="
                padding: 10px 24px;
                font-size: 16px;
                background-color: var(--primary);
                color: var(--primary-contrast);
                border: none;
                border-radius: 4px;
                cursor: pointer;
              "
            >
              Save
            </button>
            <button
              id="cancel-scanner-btn"
              style="
                padding: 10px 24px;
                font-size: 16px;
                background-color: var(--primary-dark);
                color: var(--primary-contrast);
                border: none;
                border-radius: 4px;
                cursor: pointer;
              "
            >
              Cancel
            </button>
          </div>
        </div>
      </div>
    </dialog>

    <!-- Parts List Modal -->
    <div id="parts-modal" class="modal">
      <div class="modal-content">
        <div class="modal-header">
          <h2 class="modal-title">Master Parts List</h2>
          <div style="display: flex; gap: 8px; align-items: center">
            <!-- Refresh button moved into group controls to avoid duplicate controls -->
            <button class="close-modal">&times;</button>
          </div>
        </div>
        <div id="group-controls" style="display: none; margin-bottom: 12px">
          <div
            style="
              display: flex;
              gap: 8px;
              align-items: center;
              justify-content: space-between;
            "
          >
            <div
              id="group-breadcrumb"
              style="color: #fff; font-weight: bold; flex: 1"
            ></div>
            <div style="display: flex; gap: 8px">
              <button
                id="refresh-master-btn"
                type="button"
                style="
                  padding: 6px 10px;
                  background: var(--accent-green);
                  color: var(--text-on-light);
                  border: none;
                  border-radius: 4px;
                  cursor: pointer;
                "
              >
                Refresh
              </button>
            </div>
          </div>
          <div
            id="group-hint"
            style="color: #fff; font-size: 12px; margin-top: 6px"
          >
            Select an item to navigate. Use Refresh to restart.
          </div>
          <div
            id="group-summary"
            style="
              margin-top: 10px;
              padding: 10px 12px;
              border-radius: 12px;
              background: #00264d;
              color: #fff;
              border: 1px solid rgba(255, 255, 255, 0.12);
              font-size: 13px;
              line-height: 1.3;
            "
          ></div>
        </div>
        <input
          type="text"
          class="search-box"
          placeholder="Search by Part Code or Name..."
        />
        <ul class="parts-list">
          <!-- Parts will be populated here -->
        </ul>
      </div>
    </div>

    <!-- Settings Modal -->
    <div id="settings-modal" class="modal">
      <div class="modal-content">
        <div class="modal-header">
          <h2 class="modal-title">Settings â€” Field Mappings</h2>
          <button id="close-settings" class="close-modal">&times;</button>
        </div>
        <div style="padding: 10px">
          <p style="color: #fff">
            Map Excel columns to fields shown in the app. Edit labels,
            add/remove fields dynamically. Select the Primary Scan Field for
            scan matching and Display Field for the master list view. The UI
            will update automatically when you save.
          </p>
          <div
            id="mappings-container"
            style="
              display: flex;
              flex-direction: column;
              gap: 10px;
              max-height: 60vh;
              overflow: auto;
              padding: 8px;
            "
          >
            <!-- Mapping rows will be injected here -->
          </div>
          <div style="margin-top: 12px">
            <div style="color: #fff; display: block; margin-bottom: 6px">
              Hidden Headers (removed from UI)
            </div>
            <div
              id="hidden-headers-list"
              style="
                background: #00264d;
                padding: 8px;
                border-radius: 6px;
                max-height: 160px;
                overflow: auto;
                color: white;
              "
            ></div>
          </div>
          <div
            style="
              margin-top: 12px;
              display: flex;
              gap: 8px;
              align-items: center;
              flex-wrap: wrap;
            "
          >
            <div style="min-width: 140px">Display Fields</div>
            <div
              id="display-field-container"
              style="
                display: flex;
                flex-direction: column;
                gap: 4px;
                max-height: 120px;
                overflow: auto;
                padding: 4px;
                border: 1px solid #ccc;
                border-radius: 4px;
                min-width: 220px;
              "
            ></div>
          </div>
          <div
            style="
              margin-top: 8px;
              display: flex;
              gap: 8px;
              align-items: center;
              flex-wrap: wrap;
            "
          >
            <div style="min-width: 140px">Primary Scan Fields</div>
            <div
              id="primary-field-container"
              style="
                display: flex;
                flex-direction: column;
                gap: 4px;
                max-height: 120px;
                overflow: auto;
                padding: 4px;
                border: 1px solid #ccc;
                border-radius: 4px;
                min-width: 180px;
              "
            ></div>
            <label for="scan-op-select" style="min-width: 140px"
              >Scan Operation</label
            >
            <select id="scan-op-select">
              <option value="equals">Equals</option>
              <option value="contains">Contains</option>
              <option value="startsWith">Starts With</option>
              <option value="regex">Regex</option>
            </select>
            <label
              style="
                min-width: 160px;
                display: flex;
                align-items: center;
                gap: 8px;
              "
            >
              <input type="checkbox" id="show-multi-scan-panel" /> Show
              Multi-scan Panel
            </label>
          </div>
          <div
            style="
              margin-top: 14px;
              display: flex;
              gap: 8px;
              justify-content: flex-end;
            "
          >
            <button
              id="refresh-settings"
              style="
                background: #1f4e79;
                padding: 8px 16px;
                border-radius: 6px;
                border: none;
                color: white;
              "
            >
              Refresh Master Excel
            </button>
            <button
              id="save-settings"
              style="
                background: var(--primary);
                padding: 8px 16px;
                border-radius: 6px;
                border: none;
                color: var(--primary-contrast);
              "
            >
              Save
            </button>
            <button
              id="cancel-settings"
              style="
                background: var(--primary-dark);
                padding: 8px 16px;
                border-radius: 6px;
                border: none;
                color: var(--primary-contrast);
              "
            >
              Cancel
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- License Check Modal -->
    <div id="license-modal" class="modal" style="display: none; z-index: 10000">
      <div class="modal-content" style="max-width: 500px">
        <div class="modal-header">
          <h2 class="modal-title">License Verification</h2>
        </div>
        <div style="padding: 20px; text-align: center">
          <p style="margin-bottom: 20px; font-size: 16px">
            Your license has expired. Please enter the license key to continue:
          </p>
          <input
            type="text"
            id="license-key-input"
            class="search-box"
            style="font-size: 24px; text-align: center"
            maxlength="50"
            tabindex="0"
          />
          <p
            id="license-error"
            style="color: #ff6b6b; min-height: 20px; margin: 10px 0 0 0"
          ></p>
          <div style="margin-top: 30px">
            <button
              id="verify-license-btn"
              style="
                padding: 10px 30px;
                font-size: 16px;
                background-color: #0056b3;
                color: #fff;
                border: none;
                border-radius: 4px;
                cursor: pointer;
              "
            >
              Verify License
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- License Invalid Overlay -->
    <div
      id="license-invalid-overlay"
      style="
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.8);
        z-index: 10001;
        color: white;
        text-align: center;
        padding-top: 20vh;
        font-size: 24px;
      "
    >
      License expired or invalid. Please contact support to renew your license.
    </div>
    <script>
      try {
        const { ipcRenderer } = require("electron");
        ipcRenderer.on("mobile-scan", (event, data) => {
          try {
            const code =
              (data && (data.code || data.scanned || data.scannedCode)) || data;

            // If a focused element is an editable input/textarea, insert the code there
            try {
              const active = document.activeElement;
              const isEditable =
                active &&
                (active.tagName === "INPUT" ||
                  active.tagName === "TEXTAREA" ||
                  active.isContentEditable);
              const isReadOnly = active && (active.readOnly || active.disabled);
              if (isEditable && !isReadOnly) {
                try {
                  // Insert value and dispatch input/change events so app handlers react
                  // Do not force focus or synthesize Enter key to avoid stealing focus/submitting forms
                  if (
                    active.tagName === "INPUT" ||
                    active.tagName === "TEXTAREA"
                  ) {
                    active.value = code;
                  } else if (active.isContentEditable) {
                    active.textContent = code;
                  }
                  const ev = new Event("input", { bubbles: true });
                  active.dispatchEvent(ev);
                  const ev2 = new Event("change", { bubbles: true });
                  active.dispatchEvent(ev2);
                  return;
                } catch (e) {}
              }
            } catch (e) {}

            // Otherwise, prefer the app's scan handling pipeline
            try {
              if (typeof handleScan === "function") return handleScan(code);
            } catch (e) {}

            // Fallback: put into primary field if available
            try {
              const primaryId =
                (typeof getPrimaryFieldId === "function" &&
                  getPrimaryFieldId()) ||
                (window.settings &&
                  window.settings.primaryFields &&
                  window.settings.primaryFields[0]) ||
                null;
              if (primaryId) {
                const el = document.getElementById(primaryId);
                if (el && !(el.readOnly || el.disabled)) {
                  el.value = code;
                  el.dispatchEvent(new Event("input", { bubbles: true }));
                  el.dispatchEvent(new Event("change", { bubbles: true }));
                }
              }
            } catch (e) {}
          } catch (e) {}
        });
      } catch (e) {}
    </script>
    <script src="scan-manager.js"></script>
    <script src="load-master-data.js"></script>
  </body>
</html>
